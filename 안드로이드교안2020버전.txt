[1.안드로이드 개요]

-구글이 2007년 안드로이드사를 인수하면서 시작됨.
-Android란 모습과 행동이 인간을 닮은 "인간형 로봇"을 의미한다.
-스마트폰의 OS(운영체제)이다. 가장 많이 사용하는 프로그래밍 언어인 자바와 
 익숙한 개발환경을 제공한다.  
-구글 안드로이드는 개방적이고 무료인 최초의 모바일 플렛폼이다. 
-기본적으로 리눅스 커널위에 탑재된 안드로이드 런타임인 DVM(Dalvik Virtual Machine.달빅 가상머신)에서 동작한다

-안드로이드 버전
------------------+------------+---------------+-----------------------+-------------------------------------------------------
버전코드명        |  버전번호  |  API 레벨     | 발표일                |  특징
------------------+------------+---------------+-----------------------+-------------------------------------------------------
Alpha             | 1.0        |  1            | 2008.9                |  최초 발표
------------------+------------+---------------+-----------------------+----------------------------------------
Beta              | 1.1        |  2            | 2009.2                | 버그 수정.
------------------+------------+---------------+-----------------------+------------------------------
Cupcake           | 1.5        |  3            | 2009.4                | 블루투스지원.동영상녹화등
------------------+------------+---------------+-----------------------+------------------------------
Donut             | 1.6        |  4            | 2009.9                | WVGA해상도지원.갤러리 인터페이스등
------------------+------------+---------------+-----------------------+-------------------------------
Eclair            | 2.0/2.1    |  5/6/7        | 2010.1                | 많은 해상도 지원.구글맵 향상등
------------------+------------+---------------+-----------------------+---------------------------------
Froyo             | 2.2        | 8             | 2010.5                | 전반적인 성능개선
------------------+------------+---------------+-----------------------+--------------------------------
Gingerbread       | 2.3        | 9,10          | 2010.12               | UI성능 개선,인터넷 전화등
------------------+------------+---------------+-----------------------+--------------------------------
Honeycomb         | 3.0/3.1/3.2| 11/12/13      | 2011/2월/5월/7월      | 태블릿 PC에 최적화
------------------+------------+---------------+-----------------------+-------------------------------
Icecream Sandwiich| 4.0/4.0.3  |  14/15        | 2011/10월/11월        | 진저브레드와 허니콤 통함.스마트폰과 태블릿 함께 지원
------------------+------------+---------------+-----------------------+-----------------------------------------------------------
Jelly Bean        | 4.1/4.2/4.3| 16/17/18      | 2012/7월/12월,2013/6월|다양한 액세서리 지원
------------------+------------+---------------+-----------------------+-----------------------------------------------------------
KitKat            | 4.4/4.4w   |  19/20        |  2013/10월,2014/6월   |웨어러블 확장 지원
------------------+------------+---------------+-----------------------+-----------------------------------------------------------
Lollipop          | 5.0~5.1.1  | 21/22         | 2014/10~2015/4        | 64bit지원 
------------------+------------+---------------+-----------------------+-----------------------------------------------------------
Marshmallow       | 6.0~6.0.1  | 23            | 2015/5~2015/12       | 
------------------+------------+---------------+-----------------------+-----------------------------------------------------------
Nougat            | 7.0~7.1    | 24            | 2016/9~2016/12       |  LG V20에 최초로 탑재
------------------+------------+---------------+-----------------------+-----------------------------------------------------------



[2.안드로이드 개발환경]


2-1. 안드로이드 개발환경 구성

     1)JDK  <---------------> 3)eclipse 혹은 Android Studio(2013년 5월발표)+4)ADT(Android Development Tool)<-------->2)안드로이드 SDK


     가)eclipse 혹은 Android Studio 로 프로그램 작성
     나)AVD(Android Virtual Device)룰 통해 결과 확인 --애뮬레이터 -가상의 핸드폰으로 확인


     ADT-eclipse 혹은 Android Studio와 안드로이드 SDK를 연결하기위한 플러그인
     AVD-가상 안드로이드 장치인 에뮬레이터	

     ※eclipse로 환경 설치 하려면 SDK설치 및 이크립스에서 SDK설치된 디렉토리 설정 등 모두 별도로 진행해야한다
        그러나  Android Studio의 경우 대부분 자동으로 설치되고 설정되기때문에 개발환경 구축하기가 쉬움


2-2. 이클립스로 개발환경 구축하기

	1)http://www.oracle.com사이트에서 JDK다운 및 설치
	2)http://developer.android.com/sdk/index.html -> 좌측 메뉴중 Installing the Android SDK클릭 ->Stand-alone SDK Tools클릭-> download the SDK now클릭후
	  다운 설치
	3)http://www.eclipse.orgd에서 이클립스 다운후 압축 해제
	4)이클립스에서 안드로이드 이클립스 플러그인 설치(ADT)
	  -> [ Help ] → [ Install New Software ]를 클릭한다.
	  -> Add버튼을 클릭하여 오른쪽 창을 띄운다.
	  ->Name 에는 ADT라고 입력하고 Location에는 아래URL을 입력한다.
	    https://dl-ssl.google.com/android/eclipse/
	  ->인스톨 도중에 뜨는 오류는 무시하고 모두 설치후 이클립스 재시작


2-3. Android Studio로 개발 환경 구축
      	  SDK: JDK와 같은 개념으로 실행파일이나, 개발을 위한 도구가 들어있다.

	1)http://www.oracle.com사이트에서 JDK다운 및 설치
	2)http://developer.android.com/sdk/index.html에서 Android Studio for Window다운로드 및 설치
	※설치과정중에 안드로이드 SDK가 포함되어 있다.
	※
	에뮬레이터 가속]
	SDK Manager실행
	->Extras
	->Intel x86 Emulator Accelerator
	  설치
	SDK Manager가 설치된
	디렉토리
	C:\Users\PC명\AppData\Local\Android\sdk\extras\intel\Hardware_Accelerated_Execution_Manager
	폴더가 생김
	그안의 intelhaxm-android.exe더블클릭해서 설치

	설치 여부 판단]
	dos>sc query intelhaxm
	       상태가 RUNNING중이면 살치가 된것임

2-4.안드로이드에 한글 키보드 설치(Install HangulKeyboard to emulator) ]@@@


안드로이드 에뮬레이터를 실행해 보면 기본적으로 한글 키보드는 빠져 있다.
한글 키보드를 사용하려면 apk 파일을 다운받아 따로 설치해 줘야 한다
설정에서 키보드를 바꿔주기만 하면 된다. Virtual keyboard 선택으로..



qk

※첨부한 앱을 에물레이터에 설치후 앱을 실행시켜 설정한다
교안 자료료실에서 다운 후 압축해제
C:\Users\Kosmo\AppData\Local\Android\Sdk\platform-tools 에 파일 복사해 넣기



1)에뮬레이터는 미리 실행되어 있어야 한다

2)안드로이드SDK가 설치된 디렉토리\platform-tools> adb devices
List of devices attached
emulator-5554    device
emulator-5556    device

안드로이드SDK가 설치된 디렉토리\platform-tools> adb -s emulator-5554 install com.google.android.inputmethod.korean_1.5.4.apk

Success

안드로이드SDK가 설치된 디렉토리\platform-tools>

이런식으로 각각의 에뮬레이터에 한글 키보드를 설치해주면 된다.
현재 실행되어 있는 에뮬레이터가 하나밖에 없는 경우는 안드로이드SDK가 
설치된 디렉토리\platform-tools>adb install HangulKeyboard.apk만 쳐도 된다

3) Google korean Input Setting앱을 실행후 한글 설정



※Error:CreateProcess error=216에러
  JDK 8이상 버전이 필요한데 그 이하 버전으로 설정되서 발생하는 에러
  해결책]
  File->Project Structure에서 JDK경로 변경
  위와 같이 해도 미 해결시]
  Gradle.properties에서 org.gradle.jvmargs=-Xmx1024m 에서 org.gradle.jvmargs=-Xmx512m 로 변경


  

[3.안드로이드 프로젝트의 구성]@@@

  java폴더-안드로이드 프로젝트를 생성할때 입력한 이름과 동일한 패키지명이 존재하며 그 아래에
           MainActivity.java소스가 있으며,
		   개발자는 여기서 어떤을 을 할지를 프로그래밍하게 된다.


  res폴더-앱 개발에 사용되는 이미지, 레이아웃,문자열등이 들어가는 폴더로 프로그램에 사용되는 리소스(재료)를 넣는 곳
	  ex) 그림파일 등...
          반드시 정해진 이름의 폴더와, 정해진 이름 규칙을 사용.
          파일이름은 영어 소문자, 숫자, _ 만 사용 가능.
          파일이름의 첫 글자는 반드시 영어.
          절대 대문자 사용 금지

           /drawable - 프로그램에 사용되는 이미지들을 저장하는 폴더.
	               
           /layout  - 사용자 인터페이스를 구성하는 레이아웃 파일을 저장하는곳. //activity 하나당 layout 하나 필요.
		즉 앱의 화면을 디자인한 XML파일을 저장하는 곳
	              또한 추가로 화면이 필요하면 이 곳에 XML형태로 생성하면 된다.
           /values - 애플리케이션에서 사용할 각종 데이타를 저장하는 곳.문자열,색상,스타일,배열등의 데이타를 XML형태로 저장.
	              ※ 데이터를 표현하는 XML파일
	  	 	   1) styles.xml : 스타일
	 		   2) demens.xml : 크기
			   3) strings.xml : 문자열
			   4) colors.xml : 색상
			   5) arrays.xml : 데이터 배열
	  /menu   - 메뉴 xml파일이 저장되어 있다.


  manifests폴더-AndroidManifest.xml파일이 위치한 곳으로  프로젝트의 버전이나 이름,애플리케이션의 구성요소가 추가되거나 관련 권한들을 선언하는 파일.

  gradle Scripts폴더-빌드 시스템과 관련된 파일이 들어 있으며 변경할 일은 없다.
                     주요 파일을 보면
		     build.grade(Module:app)-빌드 스크립트 핵심파일이다.
		     컴파일 버전.실행되는 최소버전등의 정보가 잇음
		     local.properties-컴파일되는 SDK의 경로가 들어 있다.

[4.Android 4대 구성요소(컴포넌트)]@@@

1) Activity

	--하나의 화면, 생명주기 가짐
	-사용자 인터페이스 화면을 구성하는 컴포넌트
	-Activity클래스를 상속한 후 생명주기 메소드를 재정의해서 원하는 기능 구현
	-화면을 구성하는 모든 클래스는 Activity를 상속받아야 한다.


2) Service
	
	--생명주기 가짐
	-액티비티와 상관없이 백그라운드에서 실행되는 컴포넌트
	-Service클래스를 상속한 후 생명주기 메소드를 재정의해서 원하는 기능 구현
	-시각적인 사용자 인터페이스를 가지지 않는다.


3) BroadcastReceiver

	-배터리 부족,시간 설정,외부전원 연결등의 특정 브로드 캐스트를 수신하거나 반응하는 컴포넌트.
	-BoradcastReceiver클래스를 상속해서  onReceive()메소드를 재정의해서 구현
	-시각적인 사용자 인터페이스를 가지지 않는다.

4) [Content] Provider

	--모델에 해당함
	-애플리케이션간의 데이터 공유를 위해 표준화된 인터페이스를 제공하는 컴포넌트
	-콘텐츠 프로바이더가 제공하는 데이타는 파일이나 데이타베이스로 존재
	-ContentProvider클래스를 상속해서 CRUD관련 메소드를 재정의해서 원하는 기능 구현
	-컨텐츠 ㅡ로바이더가 구현되어 있으면 다른 애플리케이션에서 구현된 메소드르 호출해서 데이타를 사용할 수 있다.
	-시각적인 사용자 인터페이스를 가지지 않는다.

※상기 컴포넌트를 1개 이상 만들었을 경우에는 반드시 AndroidManifest.xml파일에 선언해야 한다.
-안드로이드 3.0부터 Fragment추가됨.
 프래그먼트는 액티비티는 아니지만 액티비티 내에서 독자적으로 동작할 수 있는 
 생명주기가 있는 액티비티와 뷰의 중간위치에 해당하는 컴포넌트. 

※안드로이드 애플리케이션은 MVC모델로 구성 되었다
  MODEL:애플리케이션의 데이타를 저장하는 역할을 담담.SQLite,File,Content Provider가 이 영역에 속함
  VIEW:화면 구성을 담당.View클래스를 상속하는 컴포넌트들이 이 영역에 속함
  CONTROL:뷰와 모델을 제어.액티비티,서비스,브로드캐스트 리시버가 이영역에 속함.

 

※안드로이트 API :http://developer.android.com/reference/packages.html
 //R.java파일 위치
    //프로젝트폴더\app\build\generated\source\r\debug\com\baewoom\helloandroid_01

[5.뷰]

 - 하나의 애플리케이션은 하나 혹은 여러개의 액티비티(화면들)로 이루어 진다.
   사용자 화면(액티비티)를 구성하는 요소들을 뷰를 이용해서 만들 수 있다.
   안드로이드에서는 사용자 화면을 구성할 수 있도록 View클래스를 제공한다.
   즉 사용자 화면을 구성하는 요소를 통칭하여 뷰라고한다.

 - ViewGroup 클래스를 상속하지 않은 클래스들은 레이아웃안에 포함해서 사용한다


   View+--------TextView,EditText,Button,ImageView,CheckBox등(위젯)-눈에 보이는 컴포넌트
       |
	   |
	   |
	   +--------ViewGroup+---------LinearLayout,RelativeLayout,FrameLayout,TableLayout(레이아웃-위젯을 담는 틀)
	                     |
			             |
			             |
			             +---------ListView,GridView,Gallery,ScrollView,HorizontalScrollView,Spinner등(뷰컨테이너-레이아웃이라고 부르진 않지만 다른 위젯을 포함)

5-1]View클래스의 주요 XML속성
1))android:id속성 
	- 모든 뷰는 아이디 속성을 가질 수 있으며 자바소스에서 뷰에 접즌할때 사용
        - android:id="@+id/아이디" 형식으로 지정
        - 자바 소스에서 findViewById(R.id.아이디명)으로 접근
2)android:layout_width및 andorid:layout_height속성
	-모든 뷰의 필수 속성
	-속성값:
		wrap_content:현재 뷰의 컨텐츠를 표시할 수 있는 크기로 자동 조절하라는 의미
		match_parent:혀재 뷰를 포함하고 있는 부모 뷰의 크기만큼 가득 채우라는 의미
		※안드로이드 2.1이하버전에서 동작하는 앱을 작성하려면 match_parent대신에 fill_parent사용
		  match_parent는 2.2(프로요)부터 사용(권장)
		※가로/세로 폭을  숫자(픽셀)로 지정할 수도 있으나 화면에서 제목 부분을 세로폭에서 제외.

	
3)android:background
	-뷰의 배경색 설정 및 배경이미지 설정
	-속성값:
		#RRGGBB로 지정하거나 #AARRGGBB로 지정 배경색을 설정할 수있다.
		여기서 AA는 투명도를 나타내는 것으로
		0에 가까울 수록 투명하고 F에 가까울 수록 불투명하다.

		또한 @drawable/drawble디렉토리에 넣은 이미지명 으로 배경이미지를 설정 할 수 있다.

4)android:padding 및 android:layout_margin속성
	android:padding- 뷰 안에 포함된 컨텐츠 사이와의 여백
	android:layout_margin - 뷰와 뷰 사이의 여백

	※상기 속성은 상하좌우에 모두  같은 여백을 지정.각각 지정할 수 있는 속성도 있다.

5)android:gravity 
	-수직/수평방향 정렬 |(파이프라인)이용해서 동시 지정가능(공백없이)
	-center_horizontal:수평 기준 위쪽 가운데
	-center_vertical :수직 기준 왼쪽 가운데
	-left/right
	-center(수평 수직으로 정중앙):center_horizontal|center_vertical효과
	-top/bottom
	
	-레이아웃의 layout_width와 layout_height가 match_parent 일때 의미 있음
	-위젯안의 컨텐츠 정렬방법

6)android:visibility
	-뷰를 보일지 안보일지 설정
	-속성값:
		visible:보이는 상태(디폴트)
		invisible:안보이는 상태이고 뷰가 차지하고 있는 영역 그대로 존재
		gone:안보이는 상태이고 차지하고 있는 영역도 사라짐

7)android:enabled,android:clickable
	-enabled: 활성화 여부(디폴트 true)
	-clickable:클릭이나 터치가 가능 여부(디폴트 true)
	※enabled="true"이고 clickable="false"인 경우 버튼은 활성화 되어 있으나 클릭 혹은 터치 불가
		
5-2]주요 위젯

1) 텍스트뷰(TextView) - 화면에 고정된 텍스트 문자열을 표시하는 뷰.						
		        사용자 인터페이스를 구성하는 가장 기본적인 뷰로 에디트텍스트나 버튼들이 텍스트뷰를 상속해서 만들어짐.	
			
			주요 속성]
			text-텍스트 뷰에 보여질 문자열
			textColor- 글자의 색상 지정.#RRGGBB로 지정하거나 #AARRGGBB로 지정
			textStyle-텍스트의 스타일.bold,italic 지정. 디폴트는 normal. 예]"bold|italic"  진하고 기울어진 텍스트로 설정. |(파이프라인)으로 연결시 공백이 들어가면 안됨
			singleline-텍스트 내용이 실제 위젯보다 긴 경우 한줄로 표시해줌 즉 긴 나머지 부분은 ...으로 표시
                                   false인 경우 긴 나머지 부분은 개행되서 다음줄에 보임.디폴트는 false
								   deprecated되었다
			lines-텍스트의 줄 수를 설정.텍스트 내용이 실제 위젯보다 긴 경우 나머지는 안보임.
			textSize-텍스트 크기 설정(단위는 보통 sp로 설정)
			typeface-글꼴 설정.sans,serif,monospace 지정 .디폴트는 normal
			autoLink-URL이나 련락처가 포함된 경우 자동으로 링크를 걸어주는 속성  예]autoLink="web|phone"

			※사이즈 단위]
			px(픽셀)- 해상도에 따라 크기가 달라짐 즉(조밀조밀한 해상도와 넓은 해상도)
				      px는 한점을 의미함. 그러나 inch나 pt는 크기가 일정함

			dip(density independent pixel) 혹은  dp(dot per inch즉 inch당 점의 갯수)- 
			             해상도에 관계없이 같은 비율로 보여 줄 수 있는 단위.
			             1dp=160dpi임 즉 1dp는 1인치당 점의 개수가 160개가 들어간 크기
				     즉 스마트폰이 160dpi가 있고 320dpi가 있다면
				     1dp는 160dpi를 지원하는 스마트폰에서는 1픽셀을 차지하고
				     320dpi를 지원하는 스마트폰에서는 2픽셀을 차지한다

			sp( scale indepedent pixel)- 가변적인 길이임.즉 사용자가 스마트폰에서 글꼴(크기)를 설정하는 것에따라서 
			                             가변적으로 변할 수 있는 크기


						
2) 에디트텍스트(EditText) - 사용자에게 입력받을 수 있는 뷰.
			    텍스트뷰의 자식 클래스로 입력기능을 제외하고는 TextView와 동일
		            화면을 오래 눌러 컨텍스트 메뉴 실행 기능(복사, 
기)
			    
			    주요 속성]
			    hint-입력전에 보여주는 텍스트로 입력하면 사라진다.
			    textColorHint:hint속성에 지정한 글자색 설정
			    editable-사용자 편집 가능 여부 설정
			    password:입력시 텍스트를 ●처리하는 속성.비밀번호 입력기능
			    inputType-지정된 타입만 입력 할 수 있도록 설정(text:일반 문자,
			    textCapCharacter(대문자),
			    textEmailAddress(이메일),
			    number(숫자),
			    phone(전화번호),
			    numberPassword(password="true"와 같다)
			                date(날짜),time(시간))
				즉 설정 값에 따라 입력시 기판 모양이 달라진다.
			
			    maxLength-최대 입력 글자 수 지정
			    lines-숫자 지정. 
			    지정한 숫자 라인 만큼 텍스트를 입력할 수 있는 모양이 됨.
			    여러줄 입력 가능한 상태로 만들어짐.
			    
3) 버튼(Button) - 텍스트를 버튼의 타이틀로 사용하는 일반적인 버튼
                  상속 계층도 :TextView > Button
4) 이미지버튼(ImageButton) - 이미지를 설정해 이미지 버튼으로 사용.
                             상속 계층도:ImageView > ImageButton
			     src속성-버튼에 보여줄 이미지를 설정하는 속성
			    

5) 체크박스(CheckBox) - 여러개 선택 가능한  버튼.
                        상속 계층도: TextView > Button > CompoundButton > CheckBox
			주요 속성]
			text- 체크박스 옆에 나오는 문자열 지정
			checked-체크된 상태로 보여줄지 지정하는 속성.
			        디폴트 false


6) 토글 버튼(ToggleButton) - 전원 스위치처럼 ON, OFF를 표시하는 버튼.디폴트는 off상태						
			     상속 계층도: TextView > Button > CompoundButton > ToggleButton
			    주요 속성]
			     text속성은 의미 없음.즉 실제로 화면에 표시되지 않은다
			     textOn-상태가 On일 경우에 표시되는 문자열 지정
			     textOff-상태가 Off일 경우에 표시되는 문자열
			     checked-true일 경우 상태를 On으로 설정.디폴트는 false


						
7) 스위치(Switch) - 두개의 상태를 표시하는 버튼.
		    토글 버튼과 유사하면서 모양만 다른 버튼이다. 		    
                    상속 계층도: TextView > Button > CompoundButton > Switch
		   
		    
		    ※토글버튼과 스위치는안드로이드 4.0부터 지원되는 위젯
		      text속성이 적용되고 textOn및textOff속성은 적용안됨
		     
8) 라디오 버튼(RadioButton) - 여러 개 중에서 한 개를 선택할 수 있는 버튼
                              RadioGroup으로 여러개의 RadioButton을 묶어야 한 개의 RadioButton만 선택할 수 있다.
			      가로 배치시에는 RadioGroup에 android:orientation="horizontal"를 줘야한다.
			      상속 계층도: TextView > Button > CompoundButton > RadioButton		
			      주요 속성]
			      text- 라디오버튼 옆에 나오는 문자열 지정
			      checked-체크된 상태로 보여줄지 지정하는 속성.디폴트 false	
			    
			      	
9) 이미지뷰(ImageView) - 이미지를 보여주기 위한 뷰					
		         주요 속성]
			 src-이미지를 설정하는 속성
			 contentDescription-이미지를 보여줄 수 없는 경우 대체할 문자열.
			 scaleType-여덟 가지 값을 지정 할 수 있고 지정한 값에 따라 이미지를 확대/축소 하는 방식이 결정됨.
			 fitXY:이미지를 이미지뷰의 가로 세로 폭에 꽉 맞춘다.
			 fitStart:이미지를 이미지뷰의 왼쪽에 맞춰서 출력
			 fitEnd:이미지를 이미지뷰의 오른쪽에 맞춰서 출력
			 fitCenter :이미지를 이미지뷰 가운데 딱 맞도록 확대/축소
			 fit계열은 이미지를 이미지 뷰에 맞게 크기를 확대축소한다

			 center:이미지 원래 크기대로 이미지뷰의 가운데 출력
			 centerInside:이미지를 이미지뷰 가운데 딱 맞도록 확대/축소.fitCenter와 같다
			 ※안드로이드에서 지원하는 이미지 형식
			 .png,.9.png,jpg,gif이다
			 권장 이미지는 .png혹은 jpg이며 
			 이미지명은 영문 소문자로 시작하고 
			 숫자와 _(언더바),영문 소문자만을 사용해야 한다.

						
10) 프로그래스바(ProgressBar) - 진행상태를 보여주기 위한 뷰.						
			        두가지 형태를 사용한다. 하나는 직선형태로써 작업진행상태를 순차적으로 보여주는			
			        경우에 사용하고 원형형태는 작업진행중이라는 안내만 하려는 경우에 사용.

				주요 속성]
				-직선 형태의 프로그래스바]
				style="?android:attr/progressBarStyleHorizontal"-직선 형태의 프로그래스바 스타일 설정
				max-프로그래스바의 최대값.				
				progress-프로그래스바의 현재값
				secondaryProgress-두번째 진행상태로 앞으로 진행될 값을 미리 보여주기위한 설정
				※layout_height는 항상 wrap_content만 적용됨.숫자로 직접 높이를 설정해도 적용 안됨.
				-원형 형태의 프로그래스바]
				디폴트가 원형 프로그래스바이다
				<ProgressBar
				android:layout_width="wrap_content"
				android:layout_height="wrap_content"

				/>
				
				style="?android:attr/progressBarStyleLarge"-큰 모양의 프로그래스바
				style="?android:attr/progressBarStyleSmall"-작은 모양의 프로그래스바

				※사용자가 정의한 스타일을 적용시에는 style="@style/리소스에 설정한 스타일태그의 이름"
						
11) 시크바(SeekBar) - 프로그래스바를 확장한 뷰로 사용자가 터치로 진행 상태를 변경할 수 있도록 한 뷰.						
		      볼륨조절이나 화면 밝기 조절등에 사용된다. 발생된 이벤트는 SeekBar.OnSeekBarChangeListener				
		      인터페이스를 통해 처리한다.
		      상속 계층도:ProgressBar >AbsSeekBar > SeekBar
						
12) 스피너(Spinner) - 사용자가 여러 개의 아이템 중에서 한 개를 선택할 수 있게 해주는 뷰. 						
		      스피너는 일반적으로 콤보박스, 셀렉트박스와 유사하다.
		      ViewGroup을 상속하고 있는 뷰 컨테이너이나 뷰 컨테이너로 인식하기보다는 위젯으로 인식하고
		      더 자주 사용된다.
		      상속 계층도:ViewGroup > AdapterView > AbsSpinner > Spinner
		      spinnerMode-아이템을 보여줄 모양 설정.디폴트는 dropdown. dialog는 아이템을 다이얼로그 형식으로 표시함.
		      xml속성(entries속성)을 이용해서 아이템을 표시하거나 어댑터를 사용해서 아이템을 표시할 수 있다.

						


[6.레이아웃]@@@
1) LinearLayout	
   -리니어 레이아웃은 각 객체를 수직(Vertical) 혹은 수평(Horizontal)방향으로 배열하는 레이아웃.	
   -가장 활용 빈도가 높은 레이아웃
   주요 속성]
   -디폴트 오리엔테이션:horizontal

	android:layout_gravity
	-gravity와 속성값 동일
	-해당 위젯의 부모 뷰 안에서의 정렬방법
	-layout_width와 layout_height가 wrap_content 일때 의미 있음
	단,orientation이 vertical인 경우 속성값을 center를 줘도
	수직으로 정 가운데 오지 않고 위쪽 가운데에 위치함
	즉 다른 위젯의 배치가능성 때문에.....
	방법은 리니어 레이아웃에 gravity속성에 center를 줌
	해당 위젯의 layout_gravity속성은 생략

	※gravity는 레이아웃에 layout_gravity는 위젯에 보통 지정한다.
	※orientation이 vertical인 경우는 right,left가 적용안됨.즉 top,bottom가 적용됨
	                horizontal인 경우 top,bottomㅣ 적용안됨. 즉 right,left가 적용됨

	android:baselineAligned 
		       
			-크기가 다른 위젯을 true설정시 보기좋게  아랫라인 기준으로 정렬
			 false설정시에는 들쑥날쓱함
			-리니어레이아웃에 android:baselineAligned="true" 속성 추가
			 orientation은 horizontal로 
			 설정후  위젯의 크기를 다르게 설정하고 테스트
			 ※디폴트가 true임으로 신경쓰지 않아도 됨.

	android:layout_weight
		      - 가중치로 레이아웃의 영역을 설정
		      - 1인 위젯과 2인 위젯이 있는경우
			2인 위젯이 1보다 2배 더 큰 영역 차지 즉 2:1비율
		      예1]  
		      - orientation이 vertical인 경우
			layout_width는 match_parent로 
			layout_height는 0px(단위는 상관없음-weight에 지정한
					    가중치로 영역이 결정됨)
			layout_weight="1"

		       ※layout_weight지정시 vertical인 경우 layout_height="0dp",horizontal인 경우
		         layout_width="0dp"를 보통 지정.단,0이 아닌 ,숫자값 지정시  layout_weight속성이 무시됨.
			 
   
2) RelativeLayout	
   -릴레티브 레이아웃은 레이아웃 내부에 포함된 위젯들을 상대적인 위치로 배치하는 레이아웃.
   -상대적 위치와 관련된 속성은 렐러티브레이아웃의 상하좌우와 관련된 속성과 레이아웃이 아닌 다른 위젯의 상대위치에 관련된 속성이다.
   -상대적 레이아웃 미정시 항상 left,top이 기본

	렐러티브레이아웃의 상하좌우와 관련된 속성]-총 7개
		layout_alignParentLeft:레이아웃(부모)의 왼쪽에 배치
		layout_alignParentRight:레이아웃(부모)의 오른쪽에 배치
		layout_alignParentTop:레이아웃(부모)의 위쪽에 배치
		layout_alignParentBottom:레이아웃(부모)의 아래쪽에 배치
		layout_centerVertical:레이아웃(부모)의 수직으로 가운데에 배치
		layout_centerHorizontal:레이아웃(부모)의 수평으로 가운데에 배치
		layout_centerInParent:레이아웃(부모)의 정가운데에 배치
   
	다른 위젯의 상대위치에 관련된 속성]
	                           	         |         above               |
				         |                                |
		                     	         |alignLeft       alignRight  |         
			-----------------+----------------------------+---------------
          	                         alignTop         |                                 | alignTop
		                     	         |                                 |
                   toLeftOf        alignBaseline    |   기준 위젯                   | alignBaseline       toRightOf
                                                         |                                 |
			alignBottom      |                                 | alignBottom 
			-----------------+----------------------------+---------------
                                                         |alignLeft        alignRight  |
		                  	         |                                 |
                    			         |         below                 |

	※ XML설정파일에서 위젯추가시 부여한 아이디는 작성한 순서대로
	   참조 할 수 잇다 즉 아래에 추가한 아이디를 위에 작성한
	   위젯에서 참조 불가

	   예]
	   <TextView android:id="@+id/tv1"
	    android:layout_toLeftOf="@id/tv2"  에러
	    />
	   <TextView android:id="@+id/tv2"
	   
	    />

	
  
3) TableLayout	
   -테이블 레이아웃은 위젯을 표 형태롤 배치하는 레이아웃	
   -<TableRow>의 개수가 행의 개수가 되고,
    <TableRow>안에 포함된 위제의 개수가 열의 개수.
   -<TableRow>의 height는 width는  wrap_content로 설정됨.
    별도로 layout_width와 layout_height를 설정 불필요
    (셀에 넣을 위젯도 역시 지정 불필요)

   주요 속성]
   layout_span-테이블 레이아웃에 포함된 위젯에 설정하는 속성
               열을 병합하는 속성
   layout_column-테이블 레이아웃에 포함된 위젯에 설정하는 속성
                 지정된 열에 해당 위젯을 표시하라는 의미

    stretchColumns - <TableLayout>에 설정하는 속성으로 지정된 
                     열의 폭을 늘리라는 의미
                     만약 "*"로 설정하면 각 셀을 모두 같은 크기로 확장해서 전체 화면이 꽉차는 효과.
		     또한 ,(콤마)로 구분해서 여러열도 지정가능

    ※열번호는 0부터 시작
	
4) FrameLayout	
   -프레임 레이아웃은 왼쪽상단을 기준으로 배치하는 레이아웃이다.	
   주요 속성]
   forground-레이아웃의 전경 이미지 설정
   forgroundGravity-전경 이미지의 정렬 설정.

5) GridLayout
   -테이블 레이아웃과 마찬가지로 위젯을 표 형때로 배치할때 
     사용하는데 좀 더 직관적이다.
   -TableLayout에는 좀 어려웠던 행 확장도 
    간단하게 할 수 있어 유연한 화면 구성에 적합하다.
   -안드로이드 4.0(아이스크림 샌드위치.API 14)부터 지원
   
   주요 속성]
   <GridLayout>에 적용하는 속성]
	   -rowCount: 행 개수
	   -columnCount :열 개수
	   -orientation:그리드를 수평방향으로 먼저 채울지 ,
	                수직방향으로 먼저 채울지 지정
 
   그리드레이아웃에 포함될 위젯에 사용되는 속성]
	-layout_row:해당 위젯이 위치한 행번호
	-layout_column:해당 위젯이 위치한 열 번호
	-layoput_rowSpan:행을 지정된 개수 만큼 병합
	-layout_columnSApan:열을 지정된 개수 만큼 병합.
	-layout_gravity:주로 fill,fill_vertical,fill_horizontal등으로 지정
	                layoput_rowSpan이나 -layout_columnSApan으로 행 또는 열 병합시 ,
			위젯을 병합된 셀에 꽉 채우는 효과

	※행 혹은 열 병합 적용시에는 
	  layout_gravity속성에 fill계열 속성값을 줘야 한다.
	  화면에 맞춰서 디자인 하려면 
	  layout_width나 
	  layout_height를 숫자(주로 dp)로 직접 지정

[7.스타일과 테마]@@@

	-스타일과 테마:화면을 디자인 하는 요소로 서로 비슷한 기능이나 
	               적용범위가 다르다
	-스타일-화면의 일부분(특정 뷰)에 적용하는 것.
	        레이아웃 파일의 적용하고 싶은 뷰에 style이라는 키워드로 선언
	 스타일은 자바처럼 상속해서 확장 가능 즉 기본 스타일을 정의하고, 
	 이 스타일을 상속해서 다른 스타일을
	 만드는 것이 일반적

	예]style ="@style/스타일태그의 name속성에 지정한 이름"

	-테마-스타일을 모아서 전체 스타일을 정의하는 것(스타일 묶음).
	      매니페스트 파일에 액티비티에 선언.
	예]android:theme="@style/스타일태그의 name속성에 지정한 이름"

	스타일 적용순서]
	1.res - values디렉토리 밑에  styles.xml파일에 아래 내용 추가
	예]
	<resources>
		    <!-- Base application theme. -->
		    <style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
			<!-- Customize your theme here. -->
		    </style>
		    <!--windowNoTitle는 텍스트 뷰에 적용안됨. 
		    테마로 액티비티에 적용해야 적용됨-->
		    <style name="Theme">
			<item name="android:windowNoTitle">true</item>
		    </style>

		    <!--아래는 위 스타일 상속받은 자식 스타일-->
		    <style name="mystyle" parent="Theme">
			<item name="android:textColor">#ff0000</item>
			<item name="android:textSize">20sp</item>
		    </style>
	</resources>

	2.레이아웃 파일에서 적용코자 하는 뷰에
	style="@style/mystyle" 추가

	테마 적용순서]

	1.res - values디렉토리 밑에 styles.xml파일 작성
	예]
	<resources>

	<!-- Base application theme. -->
	<style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar">
	<!-- Customize your theme here. -->
	</style>
	<style name="Theme">
	 <item name="android:windowNoTitle">true</item>
	</style>
	<style name="mystyle" parent="Theme">
	<item name="android:textColor">#ff0000</item>
	<item name="android:textSize">20sp</item>
	</style>
	</resources>

	2.매니페스트 파일의 activity태그에
	android:theme="@style/mystyle"
	※안드로이드에서 제공하는 테마 지정시에는 @android:style로 시작
	  예]android:theme="@android:style/Theme.DeviceDefault.NoActionBar" :상태바는 있고 타이틀바가 사라짐
	     android:theme="@android:style/Theme.DeviceDefault.NoActionBar.Fullscreen":상태바 및 타이틀바 둘다 사라짐
		


	※매니페스트 파일이 아닌 자바코드로 액티비티에 테마를 적용할 수 있다.
	단,setContentView()메소드 호출전에 setTheme()메소드를 호출해야 적용됨

	setTheme(R.style.mystyle); 
	※안드로이드에서 제공하는 테마 적용시 직접 만든 
		xml파일명 대신 android.R.style.Theme_로 시작하는 상수 지정
		아래는 AppCompatActivity대신 Activity을 상속해야만 적용됨(킷켓버전 이후)

	//타이틀바(액션바) 제거
	setTheme(android.R.style.Theme_DeviceDefault_NoActionBar);
	//타이틀바(액션바)와 상태바 제거
	setTheme(android.R.style.Theme_DeviceDefault_NoActionBar_Fullscreen);
    ※자바코드로 타이틀바 없애기
	getSupportActionbar().hide()

[8.리소스]

	-리소스와 asset로 구분
        -리소스는 프로그램 코드와 함께 컴파일되는 자원들
         asset은 컴파일 되지 않고 그대로 사용하는 용량이 큰 자원(동영상)
        -리소스는 res폴더 밑에 이미 정해진 
	 특정 폴더명에 넣아야 한다.(임의로 폴더명 설정X)
         예]
             drawable -이미지 파일 혹은 XML파일
	              (도형을 정의한 파일-getDrawable()메소드로 읽어 온다)
             values   -문자열,배열,크기,색상,스타일을 지정하는 XML파일
				(getString(),
				getStringArray(),
				getIntArray(),
				getDimension(),getColor()등)
                      
                       파일명은 강제사항은 아니나 권장 파일명이 있다]
		 	strings.xml
			arrays.xml
			dimens.xml
                        colors.xml
                        styles.xml
                        
                        
             menu     -옵션메뉴나 컨텍스트 메뉴등을 
	               정의한 XML파일(별도의 읽는 메소드 없음)
             raw      -이진파일을 저장하는 폴더(폰트등)(openRawResource())
             layout   -레이아웃을 정의한 XML파일(별도의 읽는 메소드 없음)             
             xml      -앱 실행중에 읽어서 사용할 XML파일(getXml())

	     




예]

	-drawable폴더 밑에 myimg.jpg혹은 myimg.png파일 저장

	-values폴더 밑에 아래 XML파일 생성

	colors.xml]
	<?xml version="1.0" encoding="utf-8"?>
	<resources>

		<color name="mycolor">#ff0000</color>

	</<resources>

	dimens.xml]
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
		<dimen name="mysize">20sp</dimen>
	</<resources>

	strings.xml]
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
		<string name="mystring">Hello Android</string>
	</<resources>

	arrays.xml]
	<?xml version="1.0" encoding="utf-8"?>
	<resources>
	    <integer-array name="myint_array">
		<item>20</item>
		<item>30</item>
		<item>40</item>
	    </integer-array>
	    <string-array name="mystring_array">
		<item>대 청년</item>
		<item>대 회사원</item>
		<item>대 사업가</item>
	    </string-array>
	</resources>

	layout폳더의 레이아웃 설정 XML파일에서 사용하기]

	 <TextView
	    android:text="@string/mystring"
	    android:textSize="@dimen/mydimen"
	    android:textColor="@color/mycolor"
	    android:layout_width="wrap_content"
	    android:layout_height="wrap_content" />

	<ImageView
        android:src="@drawable/myimg"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

	자바 코드에서 리소스 읽어오기]

	
	  public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);

		TextView mytxt = (TextView)findViewById(R.id.mytxt);
		
		//※Resources 객체:res폴더에 정의된 
		                   모든 리소스(비트맵,XML등)를 얻어 올수 있는 클래스
		Resources res = getResources();
		String mystr = res.getString(R.string.mystring);
		/* setText()는 리소드 아이디를 넣어도 무방하다 */
		mytxt.setText(mystr);
		//mytxt.setText(R.string.mystring);//[O]
		
		/* 
		   문자열과 다르게
		   색상과 크기는 반드시 요구하는 자료형 타입을
		   넣아줘야 적용됨 즉 mytxt.setTextColor(R.color.mycolor);
		    및 mytxt.setTextSize(R.dimen.mysize);
		    는 에러는 안나지만 적용안됨
		 */
		int mycolor = res.getColor(R.color.mycolor);
		mytxt.setTextColor(mycolor);

		float mysize = res.getDimension(R.dimen.mysize);

		mytxt.setTextSize(mysize);

	  }



	※[하나의 비트맵을 읽어 들이는 과정]

	방법1]
	1] Resources res = getResources();//리소스 관리자 얻기

	2]BitmapDrawable 객체:비트맵을 확대,축소,정렬등을 할 수 있는 객체 얻기
	  BitmapDrawable  bd = (BitmapDrawable)res.getDrawable(리소스 아이디);//리소스 아이디(R.drawable.icon)

	3]자바코드에서 사용가능하도록 비트맵객체 얻기
	  Bitmap bitmap = bd.getBitmap();//비트맵 추출

	방법2]
	Bitmap bitmap = BitmapFactory.decodeResource(getContext().getResources(),R.drawable.icon



[9. 커스텀 뷰 만들기]

	9-1]View클래스를 상속해서 자바 코드로 구현

		Step1]메인 액티비티에서는 메인 레이아웃을 전개하지 않고 사용자가 만든 뷰를 
		      setContentView()메소드의 인자로 전달한다.
		      @Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);	
				//내부 클래스로 구현하거나 ,별도의 클래스로 구현
				CustomView custom = new CustomView(MainActivity.this);
				setContentView(custom);
			}


		Step2]View클래스를 상속받고  Context를 매개변수로 받는 인자 생성자를 정의하고
		      onDraw(Canvas)메소드를 오버라이딩한다. 
		      -Canvas타입의 인자로 그림을 그리고 Paint타입으로 붓의 종류를 설정

		      public class CustomView extends View{

			
			public CustomView(Context context) {
				super(context);
			}
			
			@Override
			protected void onDraw(Canvas canvas) {
				
				//배경색 설정
				canvas.drawColor(Color.GRAY);
				//붓의 종류 설정
				Paint paint = new Paint();
				paint.setAntiAlias(true);

				paint.setColor(Color.RED);
				canvas.drawPoint(100, 100, paint);
				
				paint.setColor(Color.GREEN);
				canvas.drawLine(50, 50, 100, 100, paint);
				
				paint.setColor(Color.BLUE);
				canvas.drawRect(150, 10, 250, 150, paint);
				
				paint.setColor(0x5000ffff);
				canvas.drawCircle(200, 200, 100, paint);

				Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.icon);
				/*
				public void drawBitmap(Bitmap bitmap,float left,float top,Paint paint)메소드 이용(원본 그대로 출력)
				단, 확대나 축소등을 할 수 없음(즉 전체나 부분 확대 축소 불가능)
				Paint 인자는 null로 설정
				
				public void drawBitmap(Bitmap bitmap,Rect src,Rect dest,Paint paint)메소드 이용
				src:비트맵 소스의 영역,null 설정시 비트맵 소스 영역 전체가 선택됨.
				dest: 출력할 캔바스 영역
				-비트맵을 전체 확대 혹은 전체 축소
				-특정 영역을 원하는 크기만큼 출력
				*/
				canvas.drawBitmap(bitmap,20,20,null);//원본 그대로 출력
				canvas.drawBitmap(bitmap,null,new Rect(left,top,right,bottom),null);//전체 확대/축소
				canvas.drawBitmap(bitmap,new Rect(left,top,right,bottom),new Rect(left,top,right,bottom),null);//특정 영역 확대/축소
				
			}

		}


	9-2]커스텀 뷰용 xml을 만들어서 이를 전개해서 구현-주로 커스텀 레이아웃이 필요한 어댑터뷰 계열이나 토스트등에 적용할때 



		Step1]layout폴더에 커스텀뷰용 xml을 생성한다.
			<ImageView
				android:src="@drawable/icon"
				android:layout_width="wrap_content"
				android:layout_height="wrap_content" />
			    <TextView
				android:id="@+id/textview"
				android:textSize="18sp"
				android:layout_width="match_parent"
				android:layout_height="wrap_content" />

		Step2]메인 액티비티에서  View.inflate(Context,xml파일의 리소스 아이디(커스텀뷰) 즉 메모리에 전개할 xml파일,ViewGroup의 루트) 메소드로
		      커스텀 뷰 전개
                      ※ViewGroup의 루트는 res폴더에 리소스 루트가 있는경우 null 지정 즉 
		      activity_main.xml레이아웃 파일이 있음으로 null지정
                        즉 inflate는 xml레이아웃을 메모리로 로딩해서 
			ViewGroup의 루트에게 생성된 View를 전달

			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.activity_main);

				findViewById(R.id.shortmsg).setOnClickListener(listenr);
				findViewById(R.id.longmsg).setOnClickListener(listenr);
				findViewById(R.id.custom).setOnClickListener(listenr);
			}

			View.OnClickListener listenr = new View.OnClickListener() {
				@Override
				public void onClick(View v) {
				    switch(v.getId()){
					case R.id.shortmsg:
					    Toast.makeText(getApplicationContext(),"짧은 메시지 입니다",Toast.LENGTH_SHORT).show();
					    break;
					case R.id.longmsg:
					    Toast.makeText(MainActivity.this,"긴 메시지 입니다",Toast.LENGTH_LONG).show();
					    break;
					case R.id.custom:
					    Toast toast = new Toast(MainActivity.this);
					    View view=View.inflate(MainActivity.this,R.layout.mytoast,null);
					    TextView textview = (TextView)view.findViewById(R.id.textview);
					    textview.setText("내가만든 커스텀 뷰");

					    toast.setDuration(Toast.LENGTH_LONG);
					    toast.setView(view);
					    toast.show();

					    break;
				    }
				}
			};
			


	9-3]셀렉터를 이용해 뷰의 모양 변경
	    -셀렉터는 이벤트에 따라 뷰위 모양을 변경할 수 있는 기능

	    Step1]drawable폴더에 아래와 같은 button_select.xml파일 생성
		<?xml version="1.0" encoding="utf-8"?>
		<selector xmlns:android="http://schemas.android.com/apk/res/android">

		    <!--같은 속성(state_pressed) 중복시 먼저 기술한 속성이 우선
			그리고 순서에 주의해야 함
			디폴트 이미지는 항상 맨 마지막
			pressed가 enabled보다 먼저 기술되야 한다.
		    -->
		    <item android:drawable="@drawable/button_pressed1" android:state_pressed="true" />
		    <item android:drawable="@drawable/button_pressed2" android:state_pressed="true" />

		    <item android:drawable="@drawable/button_enabled" android:state_enabled="true"/>

		    <item android:drawable="@drawable/button_default" />

		</selector>

		※이벤트에 따라 색상도 적용 가능 예] 
		<item android:state_pressed="true" 
		      android:drawable="@android:color/holo_red_light"/>

	   Step2]셀렉터(xml파일)를 뷰의 background속성에 지정
		<Button android:text="셀렉터 버튼"
		android:layout_width="match_parent"
		android:layout_height="96px"
		android:background="@drawable/button_select"
		/>
	9-4]기존 위젯을 상속받아 새로운 기능 추가등을 하여 커스텀뷰 구현

	  Step1]EditText 상속 받아 커스텀 뷰 구현
		 
		1)자바코드로 생성시나 레이아웃 XML에  
		  뷰로 등록시 전개될때 호출되는 생성자 오버라이딩

		    //자바코드로 생성시
		    public MyEditText(Context context) {
			super(context);

			Log.i("MyTag",":MyEditText1");
		    }
		    //아래는 xml에서 뷰로 설정시
		    public MyEditText(Context context, AttributeSet attrs) {
			super(context, attrs);

			Log.i("MyTag",":MyEditText2");
		    }

		2)나만의 리스너를 커스텀 뷰에 구현
			//1]인터페이스 타입의 리스너 선언
			private OnTextLengthListener onTextLengthListener =null;

			 //2] 해당 인터페이스 정의
			public interface OnTextLengthListener{
				void onTextLength(int lenght);//사용자가 입력한 문자의 길이를 전달받는 메소드
			}
			//3]커스텀 뷰에 위에서 만든 리스너를 붙일 수 있는 setter 정의
			 /*
			     반환타입은 void
			     매개변수는 인터페이스타입입 리스너
			  */
			public void setOnTextLengthListener(OnTextLengthListener onTextLengthListener){
				this.onTextLengthListener=onTextLengthListener;
		        }
			
		3)사용자가 입력한 문자열 길이를 2)에서 만든 onTextLength()메소드에 인자로 절달하도록 오버라이딩
			@Override
		    protected void onTextChanged(CharSequence text, int start, int lengthBefore, int lengthAfter) {


			//커스텀뷰에서 오버라이라딩시 문자열의 길이를 매개변수에 전달 해줌
			if(onTextLengthListener !=null)
			    onTextLengthListener.onTextLength(text.length());
			super.onTextChanged(text, start, lengthBefore, lengthAfter);
		    }

	Step2] 메인 액티비티에서 커스터뷰에 2)에서 만든 리스너 부착
		MyEditText mytext = (MyEditText)findViewById(R.id.mytext);
		final TextView tvcount =(TextView)findViewById(R.id.tvcount);

		mytext.setOnTextLengthListener(new MyEditText.OnTextLengthListener() {
		    @Override
		    public void onTextLength(int lenght) {
			tvcount.setText(String.valueOf(lenght));
		    }
		});

[10. 기타 위젯 및 고급 위젯들]


10-1]날짜/시간 관련 위젯
	-TimePicker:시/분을 선택할 수 있게 해주는 위젯
		void setCurrentHour(Integer currentHour)
		void setCurrentMinute(Integer currentMinute)
		void setIs24HourView(Boolean is24HourView) 를 통해 초기값을 설정.
		시간은 0~23, 분은 0~59 사이의 int 값을 입력.
		void setOnTimeChangedListener(TimePicker.OnTimeChangedListener callback)를
		사용해 onTimeChanged() abstract 메소드가 구현된 Listener 객체를
		등록 하여 사용자 입력을 저장/처리 


	-DatePicker:년/월/일을 선택할 수 있게 해주는 위젯
		void init (int year, int monthOfYear, int dayOfMonth, DatePicker.OnDateChangedListener callBack) 메소드를 통해 
		사용자에게 보여질 년/월/일을 설정하고 
		DatePicker.OnDateChangedListener 객체를 지정.
		월을 지정하는 int monthOfYear인자는 0~11의 값으로 설정.


	-CalendarView:달력 형태로 날짜를 표시하는 위젯.
			가로폭과 세록폭을 match_parent 로
	               showWeekNumber는 false로 설정.

	※롤리팝(5.0,API 21)이후부터 타임피커와 데이트 피커의 모양이 대폭 변경됨.
	  이전 모양을 보여주려면 TimePicker는 timePickerMode속성을 spinner로
	                         DatePicker는 datePickerMode속성을 spinner로 설정.

	※TimePicker와 DatePicker는 주로 대화 상자로 나타냄.
	  대화 상자로 나타내려면 자바코드에서 
	  TimePickerDialog,DatePickerDialog클래스를 사용.

	  DatePickerDialog-생성자를 를 이용해 초기화.
	                   DatePickerDialog(Context context, DatePickerDialog.OnDateSetListener callBack, int year, int monthOfYear, int dayOfMonth)


	  TimePickerDialog-생성자를 통해 초기화.
			   TimePickerDialog(Context context, TimePickerDialog.OnTimeSetListener callBack, int hourOfDay, int minute, boolean is24HourView)



	-AnologClock/DigitalClock:아날로그 시계와 디지털 시계를 화면에 표시해주는 위젯.
	                          단순히 시계를 표현하는 용도로 사용.
				  시간을 설정하거나 변경 불가능.
				  에뮬레이터는 시간이 시스템 시간과 맞지 않음.
				  실제 스마트폰에 업로드하면 시간이 잘 표시됨.


	-Chronometer:타이머 형식의 위젯으로 시간을 측정할때 주로 사용
	             format속성은 분:초 형식으로 출력 해주는 속성
		     예]format ="타이머:%s").
		     시간을 표시할 수 있도록 크로노 미터를 설정할 수 없다.
		     단, 자바코드를 이용해서는 가능하다
		     예]Chronometer객체.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() {
			    @Override
			    public void onChronometerTick(Chronometer chronometer) {
				long time = SystemClock.elapsedRealtime() - chronometer.getBase();
				Date date = new Date(time);
				DateFormat formatter = new SimpleDateFormat("HH:mm:ss");
				String dateFormatted = formatter.format(date);
				chronometer.setText(dateFormatted);
			    }
			});
		    

		     주요 메소드로는 start(),stop(),setBase()



	
10-2]자동 완성 관련 위젯

	

	-AutoCompleteTextView :1개의 텍스트가 자동완성
	 주요 속성으로는 completionHint(힌트로 보여줄 텍스트)와 
	 completionThreshold(몇 글자를 입력할때 목록울 보여줄 것인지를 
	 설정하는 속성)이다
	-MultiAutoCompleteTextView :
	AutoCompleteTextView를 상속받음.
	,(콤마)로 구분하여 여러개의 텍스트가 자동완성됨

	※-AutoCompleteTextView와 -MultiAutoCompleteTextView는 
	EditText뷰를 상속받음.


	예]
	레이아웃]
	<AutoCompleteTextView
        android:id="@+id/single"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="자동완성 텍스트 뷰"
        android:completionHint="선택하세요(ONE)"
        android:completionThreshold="2"
        />

    <MultiAutoCompleteTextView
        android:id="@+id/multi"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="멀티자동완성 텍스트 뷰"
        android:completionHint="선택하세요(MULTI)"
        android:completionThreshold="2"
        />
	
	자바소스]

	//데이타 준비
        String[] items ={"Adam","Advanced","Adventure","Base","baseball","Baby","Cyber"};

        AutoCompleteTextView one =(AutoCompleteTextView)findViewById(R.id.single);
        MultiAutoCompleteTextView multi =(MultiAutoCompleteTextView)findViewById(R.id.multi);

        //어댑터 생성
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,android.R.layout.simple_dropdown_item_1line,items);

        //AutoCompleteTextView에 어댑터 연결
        one.setAdapter(adapter);

        //MultiAutoCompleteTextView의 정적내부 클래스 CommaTokenizer객체 생성
        MultiAutoCompleteTextView.CommaTokenizer token=new MultiAutoCompleteTextView.CommaTokenizer();
        //MultiAutoCompleteTextView의 객체에 토크나이저 설정
        multi.setTokenizer(token);
        //MultiAutoCompleteTextView의 객체에 어댑터 설정
        multi.setAdapter(adapter);

10-3]작업진행정도 관련

	-ProgressBar/SeekBar
	-RatingBar:진행상황을 별 모양으로 표시.
	           선호도를 표시할때 주로 사용
	           주요 속성으로는 numStars(별의 개수 설정),
		   rating(초기값 설정),
		   stepSize(한번에 채워지는 개수 설정)




10-4]뷰 커네테이너 계열
     -ViewGroup하위 클래스로 레이아웃 계열을 제외한 것들을 주로 
      뷰 컨테이너락도 하는데 다른 위젯을 담은 그릇역할을 한다.

     -ScrollView:수직으로 스크롤하는 기능. 
                 단 하나의 위젯만 넣을 수 있다.
		 그래서 스크롤뷰에 레이아웃계열 뷰를 넣고 
		 레이아웃 안에 여러 위젯을 넣는 게 일반적
     -HorizontalScrollView:수평으로 스크롤. 그외는 ScrollView와 동일하다.


     -SlidingDrawer:위젯들을 서랍처럼 열어서 보여주거나 닫아서 
                    감추는 기능을 갖는 뷰컨테이너
                    단, API 17에서 Deprecated됨.
	
	
	<SlidingDrawer handler="손잡이명" content="컨텐츠명">
		<버튼 id="손자이명"/>   
		<!-- 서랍 손잡이 : 버튼 대신 이미지뷰나 이미지버튼 사용해도 됨 -->
		<리니어레이아웃 id="컨텐츠명">
			<!-- 서랍 내부이며 치곳에 필요한 위젯들을 넣은다-->
			
		</리니어레이아웃>
	</SlidingDrawer>



    -ViewFlipper:여러개의 위젯을  미리 배치한 후 필요에 따라서 
                 화면을 왼쪽과 오늘쪽으로 밀어서 하나의
                 위젯씩 보여주거나,혹은 설정한 시간 간격으로 
		 자동으로 하나씩 보여주는 방식의 뷰 컨테이너
		 실제 동작은 자바코드로 해야 한다.
		<리니어레이아웃>
			
			<리니어레이아웃>
				왼쪽 /오른쪽으로 전환할 버튼 또는 이미지뷰
			</리니어레이아웃>

			<ViewFlipper>
				//한번에 하나씩 보여줄 위젯 배치.
				  만약 한번에 보여줄 위젯이 여러개라면 
				  뷰플리퍼안에 레이아웃을
				//넣고 ,각 레이아웃에 필요한 위제 배치

			</ViewFlipper>


		</리니어레이아웃>

		주요 메소드]
		showPrevious():이전 위젯(화면) 보여주기
		showNext():다음 위젯(화면) 보여주기
		setFlipInterval(1000분의 1초):1000분의 1초 단위로 
		                              화면 넘김 간격 설정
		startFlipping():화면 넘김 시작 메소드
		stopFlipping():화면 넘김 중지 메소드


   -TabHost:탭 메뉴 처럼 각 탭을 클릭할때마다 해당 화면이 나오도록 설정하는 
            뷰 컨테이너.
            ViewFlipper 처럼 실제 동작은 자바코드로 구현해야 한다.
            안드로이드폰 화면에서는 보통 탭 화면이 3개 정도가 적당하다.

	    ※API 13 부터 TabActivity 클래스가 공식 지원 목록에서 제외됨으로써,
	      Tab 기능을 구현할때, TabActivity 와 TabHost 뷰 대신
              FragmentActivity 클래스와 FragmentTabHost 뷰를 
	      사용할 것을 권장 

		※2019년 초  FragmentTabHost또한 Deprecated됨
		TabLayout 과 ViewPager를 사용할 것을 권장함. 



	    메인 레이아웃.xml]
	    <android.support.v4.app.FragmentTabHost id="@android:id/tabhost>
		<리니어레이아웃>

			<TabWidget id="@android:id/tabs"/>
			<!-- 실제 사용하지 않으나, 구성상 반드시 필요함. -->
			<FrameLayout
			    android:id="@android:id/tabcontent"
			    android:layout_width="0dip"
			    android:layout_height="0dip"
			    android:layout_weight="0" />

			<!-- 실제 화면에 출력될 컨텐츠를 표시할 레이아웃 -->
				<FrameLayout
				    android:id="@+id/realtabcontent"
				    android:layout_width="match_parent"
				    android:layout_height="0dp"
				    android:layout_weight="1" >
		</리니어레이아웃>
	   </android.support.v4.app.FragmentTabHost>
	

	   ※id는 안드로이드에서 제공하는 아이디임으로 변경불가.

	   자바코드로 탭화면 구성]
	   1. FragmentActivity를 상속 받는다
	   2. findViewById(android.R.id.tabhost)메소드로 전개된 xml의 FragmentTabHost를 얻는다
	   3. 2에서 얻은 FragmentTabHost의 setup(this, getSupportFragmentManager(), R.id.realtabcontent)메소드로 실제 탭 내용을 표시할 레이아웃을 FragmentManager연결
		FragmentManager가 Fragment를 FragmentActivity에 표시하는 역할을 함
	   
	   4. FragmentTagHost의 addTab(tabHost.newTabSpec("탭구분자").setIndicator("탭메뉴명"),Fragement를 상속받은 탭을 구성하는 클래스, null)메소드로 하나의 완전한 탭 메뉴에 따른 탭화면 구성 완료
	     예]addTab(tabHost.newTabSpec("tab0").setIndicator("탭메뉴1"),MyTabFragment1.class, null)


	
	   5. android.support.v4.app.Fragment를 상속 받는 클래스 작성

		예]
		public class MyTabFragment1 extends android.support.v4.app.Fragment{

		    @Nullable
		    @Override
		    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
			//탭화면에 보여줄 레이아웃 전개
			View view = inflater.inflate(R.layout.mytab1,container,false);
			//전개한 뷰반환
			return view;
		    }
		}

	  6. 탭화면용 레이아웃 작성
	  예]
	  <?xml version="1.0" encoding="utf-8"?>
	<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	    android:orientation="vertical" android:layout_width="match_parent"
	    android:layout_height="match_parent">
	    <ImageView
		android:layout_width="match_parent"
		android:layout_height="match_parent"
		android:src="@drawable/img1"
		/>
	</LinearLayout>

      -WebView: 웹브라우저 기능을 앱(App) 안에 포함 시킬수 있는 위젯
                사용시에는 매니페스트 파일(AndroidManifest.xml)에 
		android.permission.INTERNET권한을 추가해야 한다
		loadUrl()메소드로 컨텐츠 표시
		(반드시 http프롷토콜도 지정해줘야 한다)
		
		WebView와 관련된 주요 클래스]
		WebSettings:웹뷰 설정과 관련된 클레스.WebView의 getSettings()메소드로 얻는다.
		           예]
				//자바스크립트 허용
				webview.getSettings().setJavaScriptEnabled(true);
				//줌 컨트롤 사용여부 지정
				webview.getSettings().setDisplayZoomControls(true);

		WebViewClient:웹 페이지 로딩 담당.WebView의 setWebViewClient(WebViewClient를 상속 받은 클래스 객체);
		              WebViewClient를 상속 받은 클래스 객체는 shouldOverrideUrlLoading()메소드 오버라이딩
		WebChromeClient:자바 스크립트 경고 처리.WebView의 setWebChromeClient(WebChromeClient를 상속 받은 클래스 객체)\
			      WebChromeClient를 상속 받은 클래스 객체는 onJsAlert()메소드 오버라이딩.
			      예]
			       class MyWebChromeClient extends WebChromeClient{

				@Override
				public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
				    //잡스크립트이 경고창을 토스트로 보이도록 오버라이딩
				    Toast.makeText(MainActivity.this,message,Toast.LENGTH_SHORT).show();
				    //자바스크립트 경고창의 확인버튼을 클랙한것으로 처리하도록 호출
				    //미 호출시 경고창이 계속 화면에 떠 잇는 것으로 간주되어ㅏ
				    //경고창이 더 이상 뜨지 않는다
				    result.confirm();
				    return true;
				}
			    }

			      WebChromeClient의 기본 경고창 사용시에는  웹뷰.setWebChromeClient(new WebChromeClient);호출.
			      즉 WebChromeClient를 상속 받은 클래스를 상속받은 클래스를 생성 불필요



[11.이벤트]@@@

	1] 이벤트(Event)란 사용자 또는 프로그램 코드에 의해서 발생하는 사건
  
	2] 이벤트 처리를 위한 기본 개념

		- 이벤트소스(Event Source):  이벤트가 발생한 컴포넌트 객체를 의미
		- 이벤트핸들러(Event Handler): 이벤트를 처리하기 위한 클래스로 이벤트가 발생햇을때 처리방법은
					       다양함으로 인터페이스에 정의만 되어 있고 구현은 직접 프로그래머가 구현함.
					       그리고 이런 이벤트 핸들러를 정의한 인터페이스를 리스너 인터페이스라 함

	

	3] 이벤트 핸들러 클래스의 구성 요건

	   1.  OnXXXListener란 인터페이스 상속 받아서 구현
	   
		예] Button 뷰를 클릭할때 -> Click 이벤트 발생 ->  OnClickListener 를 상속받는 클래스를 구성.
		    라디오버튼 혹은 체크박스를 선택할때 ->CheckedChanged이벤트 발생 ->OnCheckedChangeListener
		    스피너 선택할때 ->ItemSelected이벤트 발생 ->OnItemSelectedListener
       
	   2. 리스너 인터페이스를  상속받은 클래스(이벤트 핸들러)는 반드시 추상메소드를 재정의해야 한다.
	      이 메소드가 바로 이벤트를 처리해주는  메소드가 된다.
		       예]  OnClickListener -> onClick(View v)
			    OnCheckedChangedListener ->onCheckedChanged(CompoundButton buttonView, boolean isChecked)
			    OnItemSelectedListener-> onItemSelected(AdapterView<?> parent, View view, int position, long id)와 onNothingSelected(AdapterView<?> parent)

	4] 이벤트 소스와 이벤트 핸들러 연결

	     이벤트소스. setOnXXXListener(이벤트 핸들러 객체)메소드를 이용해서 연결
	     
	     예]btnok.setOnClickListener(핸들러객체);

	5]이벤트 처리 방법
	
		1. 이벤트소스(컴포넌트)를 가지는 액티비티가 핸들러가 되는 방법
		2. 이벤트 핸들러를 내부 멤버 클래스(Inner class)로   별도로 구성하는 방법
		3. 이벤트 핸들러를 익명 내부클래스로 구성
		4. 콜백 메소드 재정의 -OnTouchEvent
		5. 사용자 정의 리스너 구현- [9. 커스텀 뷰 만들기] 팜조


	6]주요 이벤트 리스너
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	이벤트                                                  |  이벤트 리스너                                        | 재정의 메소드
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	뷰를 클릭할때                                           | OnClickListener                                       | onClick
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	뷰를 길게 클릭할 때                                     | OnLongClickListener                                   | onLongClick
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	뷰를 터치할때                                           | OnTouchListenr                                        | onTouch
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	컨텍스트 메뉴가 생성될 때                               | OnCreateContextMenuListener                           | onCreateContextMenu
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	체크할 수 있는 아이템 선택시(체크박스,라디오버튼등)     | OnCheckedChangedListener                              | onCheckedChanged
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------
	선택할 수 잇는 아이템 선택시(스피너,리스트뷰등)         |  OnItemSelectedListener                               |  onItemSelected
	--------------------------------------------------------+-------------------------------------------------------+------------------------------------------------------------------

	7]뷰(화면)의 MotionEvent(터치)
	-뷰 클래스를 상속받아 생성한 커스텀 뷰(화면)를 터치하면 MotionEvent가 발생.
	 콜백 메소드인 View클래스의 콜백 메소드인 onTouchEvent()메소드를 오버라이딩해서 구현

	 MotionEvent의 주요 상수]
    	 ACTION_DOWN-화면을 터치 했을때
	 ACTION_MOVE-터치후 손가락을 움직일때
	 ACTION_UP  -화면에서 손가락을 뗐을때




[12.메뉴와 통지(Notificartion)]

	메뉴]
		-안드로이드 메뉴에는 옵션 메뉴와 컨텍스트 메뉴 두가지가 있다.
		-옵션 메뉴:안드로이드기기의 메뉴버튼을 클릭했을때 화면 하단에 나오는 메뉴
		-컨텍스트 메뉴:뷰나 위제등릏 롱 클릭시 화면 중앙에 팝업 형태로 보이는 메뉴


	Notification]
		-사용자에게 애플리케이션에서 발생한 이벤트를 알리는 컴포넌트로
		 토스트,상태바,다이얼로그 가 있다.
		-토스트:폰 화면 하단 중앙에 메시지가 있는 사각형 형태로 보여주는 방식.사용자에게 당장 알려줘야하는 정보가 있을때 사용
		-상태바:SMS,이메일 수신,애플리케이션 업데이트등을 표시하고 이를 클릭 했을때 상세 내용을 보여주는 방식.급한 정보가 아닌
	         나중에 볼 수 있도록 알려만 줘도 되는 경우에 사용	
		-다이얼로그:화면중앙에 다이얼로그 창을 보여주는 방식.사용자의 결정이 반드시 필요할때 사용
	


  
12-1]Option Menu  생성

	1)XML을 이용한 옵션 메뉴

		Step1] res의 menu폴더에 메뉴 XML 파일 생성 혹은 편집-메뉴 코딩
		예]
		menu_option.xml생성
		<?xml version="1.0" encoding="utf-8"?>
		<menu xmlns:android="http://schemas.android.com/apk/res/android">


                   <!--액션바(타이틀바)에 메뉴 표시(메뉴 인플레이트해야 적용 됨.자바코드로 불가)>
		   <item
			android:id="@+id/actionMenu01"
			android:title="액션메뉴1" 
			android:orderInCategory="1" <!--보여지는 메뉴순서-->
			android:showAsAction="always" <!-- 액션바에 메뉴가 보이도록 설정-->
			android:icon="@drawable/actionmenu01"  <!-- 이미지로 메뉴 표시 .생략시 android:title속성에 지정한 메뉴명이 보임-->
			/>

		    <item
			android:id="@+id/actionMenu02"
			android:title="액션메뉴2" 
			android:orderInCategory="2" <!--보여지는 메뉴순서-->
			android:showAsAction="always" <!-- 액션바에 메뉴가 보이도록 설정-->
			android:icon="@drawable/actionmenu02"  <!-- 이미지로 메뉴 표시 .생략시 android:title속성에 지정한 메뉴명이 보임-->
			/>
	            <!--아래는 옵션메뉴들(자바코드로도 메뉴 생성 가능)--->
		    <item
			android:id="@+id/menuRed"
			android:title="RED(배경색)"
			/>
		    <item
			android:id="@+id/menuGreen"
			android:title="GREEN(배경색)"
			/>
		    <item
			android:id="@+id/menuBlue"
			android:title="BLUE(배경색)"
			/>

		    <!-- 메뉴 안에 서브 메뉴 만들때-->
		    <item android:title="이미지 변환▶">
			<menu>
			    <item
				android:id="@+id/submenuRotate"
				android:title="90도씩회전"
				/>

			    <item
				android:id="@+id/submenuAdd"
				android:title="2배씩확대"
				/>
			    <item
				android:id="@+id/submenuMinus"
				android:title="2배씩축소"
				/>

			</menu>


		    </item>
		</menu>
		Step2] onCreateOptionMenu() 콜백 메소드 오버라이딩-메뉴 XML파일 전개

			예]
			 @Override
			    public boolean onCreateOptionsMenu(Menu menu) {

				getMenuInflater().inflate(R.menu.option_menu, menu);
				return true;
			    }

		Step3] onOptionsItemSelected()메소드 오버라이딩-메뉴 선택시 실행할 내용 코딩

		@Override
		    public boolean onOptionsItemSelected(MenuItem item) {


			switch(item.getItemId()){
			    case R.id.menuRed:
				linearLayout.setBackgroundColor(Color.RED);
				return true;

			    case R.id.menuGreen:
				linearLayout.setBackgroundColor(Color.GREEN);
				return true;
			    case R.id.menuBlue:
				linearLayout.setBackgroundColor(Color.BLUE);
				return true;
			    case R.id.submenuRotate:
				rotation+=90;
				if(rotation >360) rotation=0;
				imageView.setRotation(rotation);
				return true;
			    case R.id.submenuAdd:
				scaleSize+=2;

				imageView.setScaleX(scaleSize);
				imageView.setScaleY(scaleSize);
				return true;
			    case R.id.submenuMinus:
				scaleSize-=2;

				imageView.setScaleX(scaleSize);
				imageView.setScaleY(scaleSize);
				return true;

			    case R.id.submenu:
				return false;



			}
			//메뉴 아이템이 선택되엇을때 아무것도 반환(true든 false든)하지 않으면
			// super.onOptionsItemSelected(item)는 false반환
			Toast.makeText(MainActivity.this,"super:"+super.onOptionsItemSelected(item),Toast.LENGTH_SHORT).show();
			return super.onOptionsItemSelected(item);
		    }

	2)자바코드만으로 옵션 메뉴 생성

	        메뉴 추가]
		OnCreateOptionMenu(Menu menu)메소드 안에서 인자로 넘어온 Menu객체의
		add(int groupId,int itemId,int order,CharSequence title)메소드로 메뉴 추가
		인자 설명]
		groupId:그룹아이디로 그룹에 포함되않은 경우는 Menu.NONE이나 0설정
		itemId:메뉴 아이템의 아이디,필요 없을 경우 Menu.NONE 이나 0
		order:메뉴 아이템의 순서.순서를 지정하고 싶지 않으면 Menu.NONE 이나 0
		title:메뉴명
		

		서브 메뉴 추가]

		Menu객체의 addSubmenu("서브메뉴 타이틀")메소드로 SubMenu타입을 얻은 후
		역시 add()메소드로 서브메뉴를 추가
		

		메뉴 선택시 실행코드는 위와 동일하다.

		예]
		@Override
		    public boolean onCreateOptionsMenu(Menu menu) {
			//방법1]메뉴 xml사용
			//getMenuInflater().inflate(R.menu.option_menu, menu);
			//방법2]자바코드로 구현
			
			menu.add(Menu.NONE,1,0,"#FF0000(배경색)");
			menu.add(0,2,Menu.NONE,"#00FF00(배경색)");
			menu.add(Menu.NONE,3,0,"#0000FF(배경색)");

			//서브 메뉴
			SubMenu submenu=menu.addSubMenu("이미지 변환▶");
			submenu.add(0,4,0,"90도씩회전");
			submenu.add(0,5,0,"2배씩확대");
			submenu.add(0,6,0,"2배씩축소");
			return true;
		    }



12-2]Context Menu생성


	1)XML을 이용한 Context Menu 생성]-Step2 추가되고 오버라이딩할 메소드가 다르다.
	그외는 옵션 메뉴 생성과 거의 동일하다

	Step1] res의 menu폴더에 메뉴 XML 파일 생성 혹은 편집-메뉴 코딩
	       -메뉴 XML파일은 컨텍스트 메뉴가 나오게 할 위젯마다 별도의 파일로 만들어야 한다

	Step2]onCreate()안에 registerForContext()메소드로 컨텍스트 메뉴를 사용할 위젯 등록

	Step3]OnCreateContextMenu(ContextMenu menu) 콜백 메소드 오버라이딩-메뉴 XML파일 전개
              ContextMenu타입은 setHeaderIcon()이나 setHeaderTitle()메소드로 컨텍스트 메뉴의(팝업형태)
	      타이틀 아이콘이나 제목을 설정 할 수 있다.단, AVD에서는 아이콘이 나타나지 않을 수도 있다



	Step4]onContextItemSelected()메소드 오버라이딩-메뉴 선택시 실행할 내용 코딩


	2)자바코드로 구현하는 것은 옵션메뉴와 동일하다.단 팝업 형태임으로 SubMenu타입은 불필요 




12-3]토스트

	-화면에 잠깐 니타낫다 사라지는 메시지.사용자가 인식해야할 작은 메시지를 보여줄때 사용하면 편리.
	 프로그래머가 디버깅용으로도 사용하기 편리.

	 형태]
	 Toast.makeText(Context context,String message,int duration).show();

	 Conetxt:토스트를 띄울 컨텍스트(화면)
	 duration:화면에 나타나는 유지시간.Toast.LENGTH_LONG이나 Toast.LENGTH_SHORT중 하나
     show():토스트를 화면에 보여주는 메소드.

	 ※토스트는 기본적으로 화면의 중앙 하단 부근에 표시되는 데 Toast의 setGravity(int gravity,int xOffset,int  yOffset)
	  으로 위치를 설정할 수 있다.
	  예]
	Toast toast=Toast.makeText(getApplicationContext(), "토스트입니다", Toast.LENGTH_SHORT);
	toast.setGravity(Gravity.CENTER,0,0);//화면의 중앙에서 x,y축으로 0만큼 떨어짐 즉 가운데 표시됨.
    toast.show();


12-4]대화상자

	-화면에 메시지를 나타낸후 확인이나 취소 같은 사용자의 선택을 받는 경우에 사용.토스트보다 사용자에게
	 더 강한 메시지를 보낼 수 있다.


	기본 대화상자]
	1)AlertDialog.Builder클래스로 생성
	2)생성시 용도에 따른 대화 상자 설정
	  .setTitle():대화 상자의 제목
          .setMessage():대화 상자 내용
	  .setIcon():아이콘 설정
	  .setPositiveButton("문자열",리스너):OK버튼 보이기
	  .setNegativeButton("문자열",리스너):CANCEL버튼
	  .setItems(배열혹은 리소스아이디,리스너):목록 형태로 사용자에게 알려줄 아이템 출력
	  .setSingleChoiceItems(배열혹은 리소스아이디,인덱스,리스너):라디오버튼 목록 형태- 인덱스에 -1을 주면 체크가 안된 상태로 보임
	  .setMultiChoiceItems(배열혹은 리소스아이디,선택 여부 boolean형 배열,리스너):체크 박스 목록 형태
	3)show()메소드로 대화상자 화면에 보이기


	※setMessage()설정시 .setItems(),setSingleChoiceItems() 혹은 setMultiChoiceItems()적용이 안되고
	  setMessage()가 우선 적용되어 대화 상자 메시지를 보여줌.


	진행바 대화상자]
	1)ProgressDialog클래스로 생성
	2)생성시 진행바 대화 상자 설정
            progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER):막대 혹은 원형 모양의 프로그레스바 설정
            progressDialog.setIcon(R.drawable.icon);
            progressDialog.setTitle("제목설정");
            progressDialog.setMessage("대화상자 메시지");
            progressDialog.show();

	 ※커스텀 대화상자는 AlertDialog.Builder클래스의 setView()메소드로 커스텀뷰 설정

12-5]상태바
	-화면상단에 보여주는 것이 상태바 통지다.이 기능은 SMS 도착 여부,부재중 전화 ,이메일 수신등을
	 아이콘으로 표시하고 이를 클릭했을때
	 상세 내용을 보여주는 방식이다.사용자에게 어떤 정보를 알려줘야 하지만 급한 내용은 아니기때문에 나중에
	 볼 수 있도록 알려만 줘도 되는 경우 사용.

	 1)NotificationManager클래스로 생성
	   notificationManager
                            =(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);

	 2)노티 클릭시 보여줄 화면을 위한 인텐트 및 펜딩 인텐트 생성
	   //노티 클릭시 이동할 화면정보를 가진 인텐트 생성
	    Intent intent = new Intent(MainActivity.this,NotiInformation.class);
	    intent.putExtra("Alert", "USB대한 추가 정보 입니다.");

	    //사용자 가 노티 클릭시 위의 인텐트를 전달하도록 펜딩 인텐트 사용
	    //PendingIntent.FLAG_UPDATE_CURRENT:펜딩 인텐트가 이미 존재한다면 이를 그대로 유지하는 대신에 추가 데이터를
	    //새로 생성된 펜딩 인텐트의 것으로 변경한다
	    PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);

	   
	 3)통지와 관련된 정보(아이콘,메시지등)를 가지고 잇는 Notification객체 생성
	   Notification notification = new Notification.Builder(MainActivity.this)
	    //노티 아이콘
	    .setSmallIcon(R.drawable.icon)
	    //상태바에 잠시 표시되는 티커
	     .setTicker("알림 메시지 도착")
	    //노티 클릭시 표시되는 제목
	    .setContentTitle("미디어 디바이스로 연결")
	    //내용
	    .setContentText("기타 USB옵션을 보려면 누르세요")
	    //노티 클릭시 상태바에서 자동으로 사라지도록 설정
	    .setAutoCancel(true)
	    //실행할 펜딩 인텐트 설정정
	   .setContentIntent(pendingIntent)
	    .build();
	 3)NotificationManager의 notify(int통지아이디,Notification객체)메소드를 통해 상태바에 Notification객체를 적용.
	   통지 아이디는 어플리케이션의 유일한 식별자로 다음 통지시에는 다른 아이디값을 설정해야 한다.
	   notificationManager.notify(1,notification);	


[13.액티비티]@@@

	-안드로이드 4대 컴포넌트중의 하나로 
	 앱의 화면을 구성하는 가장 기본적인 컴포너트다

13-1]액티비티 생성 방법

	 1) 액티비티 레이아웃 작성-일반적으로 액티비티 하나당 
	                            xml레이아웃 파일 하나를 만들어서 사용
	 2) Activity를 상속받아 액티비티 클래스 작성
	 3) 매니페이스트 파일(Androidmanifest.xml)에 액티비티 정보 추가


13-2]액티비티 생명주기



			액티비티 시작                                      
		---------------------------------------------

			onCreate() :액티비티가 생성될때 호출되며 UI초기화에 사용.
			               내부에서 setContentView()사용  
			    |
			    ↓
	onRestart()-->  onStart():액티비티가 사용자에게 보여지기 바로 직전에 호출됨.     
	 ↑		   |
	 |		   | --onRestoreInstanceState(Bundle):액티비티의 생명주기 아님--activity의 상태를 복구
			   ↓	 		
	 |		onResume():액티비티가 사용자와 상호작용하기 바로전에 호출됨. <----------+
	 |                 |                                                                    |
	 |		   ↓                                                                    |
	 |	........액티비티가 실행됨..........................                                   |
	 |		   |                                                                    |
	 |      ........다른 액티비티가 실행됨...............                                   |
	 |                  ↓	                                                                |
	 |              onPause() --------------------------------------------------------------+  :다른 액티비티가 보여질때 호출됨.데이타 저장.스레드 중지등의 처리를 하기에 적당.
	 |                 |
	>onSaveInatsnceStae():액티비티의 생명주기 아님
	 |	           ↓		 
	 +--------------onStop():액티비티가 사용자에게 더이상 보여지지 않을때 호출됨.(백그라운드에 있는것)
				홈버튼 눌럿을 때와 동일. 메모리 부족시 호출되지 않을 수도 있음     
			   |
			   ↓			
			onDestroy():액티비티가 소멸될때 호출됨 즉 
			어플리케이션이 종료될때 .
			finish()메소드를 호출하거나 
			시스템이 메모리 확보를 위해 액티비티를 제거할때 호출됨.
			

      
	onRestart():stop상태에 있다가 액티비티가 실행될때 호출됨.

	※onStop()및 onDestroy()메소드는 호출되지 않을 수도 있다.
        
	※주요 액티비티 상태
	onCreate() : 액티비티 초기화,
	onResume() : 액티비티 상호작용,
	onPause() : 액티비티 중지시
	에 어플리케이션과 관련된 주요 코드를 주로 작성한다.

	※onSaveInstanceState(Bundle bundle):
	화면 모드 변경시나 다른 액티비티 실행시  
	이전 액티비티의 상태를 저장할 수 있는 메소드로 
	onPause()메소드 호출후에 호출됨.
	onRestoreInstanceState(Bundle):이렇게 자장된 생태를 다시 
	복구 할 수 있도록 onResume()메소드 이전에 호출되는 메소드.
	   
          onSaveInstanceState(Bundle bundle)메소드로 저장한 상태는
	  onCreate(Bundle)메소드와  onRestoreInstanceState(Bundle)메소드 
	  둘 다에서 복구 할 수 있다.
	  이유는 액티비티의 자원을 초기화하는 시점에 필요한 상태 정보와 
	  모두 초기화 한 후에 필요한 상태 정보가 다를 수 있기때문이다.

         
	※화면모드 변경시 액티비티의 콜백 메소드 순서
	
	액티비티 시작-->onCreate-->onStart--->onResume-->액티비티 실행됨--->화면모드 변경--->
	--->onPause-- >onSavedInstanceState--->onStop--->onDestroy--->액티비티가 재시작됨
	--->onCreate--->onStart--->onRestoreInstanceState--->onResume--->액티비티 실행됨(모드가 변경된 화면)


	화면모드 변경 방법]
	1)AndroidManifest.xml파일의 액션 태그에 설정-화면모드 고정
	 가로 모드로 설정시-screenOrientation="landscape" 
	 세로 모드로 설정시-screenOrientation="portrait" 

	2)자바코드로 동적으로 설정
	 가로 모드로 설정시-setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
	 세로 모드로 설정시-setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

	※onSvaedInstanceState()메소드는 finish()메소드(액티비티 종료 임으로)가 
	액티비티에서 호출되거나 
	사용자가 Back 버튼(액티비티가 종료됨)을 클릭했을때는 호출되지 않는다.
	 단,Home버튼을 누르면 onPause()->onSaveInstanceState(Bundle outState)->onStop()로 
	 액티비티가 종료되지 않은 상태임으로  onSvaedInstanceState()메소드가 
	 호출된다.
	 즉 액티비티 종료시에는 액티비티의 상태를 저장할 필요가 없음으로 
	 호출이 안된다.




	
[14.인텐트(Intent)]@@@

14-1]인텐트와 인텐트 필터란?
	1)Intent 
		-컴포넌트(액티비티나 브로드캐스트 리시버등)에 액션,데이타들을 전달하는 메시지 객체
		-이 컴포넌트를 이용해서 다른 액티비티를 실행하거나 다른 액티비티에 데이타를 전달 할 수 있다.
		-전달하는 요소중 액션은 크게  액티비티를 어떻게 실행할지를 결정하는  
		액티비티 액션과 브로드캐스트 리서버에 전달하는 
		브로드캐스트 액션이 있다.

		예]
		   액티비티 액션]
		   -액티비티를 실행할때 사용하는 
		   startActivity (Intent객체) 메소드에 지정하는 
		   인텐트 객체 생성시 설정한다.

		   ACTION_MAIN :시작 액티비티를 지정하기위한 액션
		   ACTION_VIEW :데이타 URI로 적절한 액티비티를 호출하는 액션
		   ACTION_DIAL:전화 다이털 액티비티를 호출하는 액션
		   ACTION_CALL:전화를 거는 액션//보안 때문에 못하고 사용자 권한이 필요
		   ※ACTION_DIAL와  ACTION_CALL차이점
		     ACTION_CALL는 매니페스트 파일에 퍼미션(android.permission.CALL_PHONE)을 추가해야 한다.
		     또한 ACTION_CALL바로 통화를 거는 화면이 나온다


		   브로드캐스트 액션]
		   -registerReceiver(BroadcastReceiver객체,IntentFilter객체)메소드의 IntentFilter객체 생성시 정의하거나
		     AndroidManifest.xml파일의 <receiver>태그안에 정의 할 수 있다.

		     ACTION_TIME_CHANGED:현재 시간이 설정되었음을 알려주는 액션
		     ACTION_BATTERY_CHANGED:배터리 정보가 변경되었음을 알려주는 액션
		     ACTION_POWER_CONNECTED:외부전원이 연결되었음을 알려주는 액션

	2)IntentFilter
		-특정 인텐트를 받을지 말지를 정의하는 역할 수행.
		이를 통해 컴포넌트의 특징이 정해진다
		예]AndroidManifest.xml파일에 아래와 같이 인텐트 필터가 선언된 경우
		   - 해당 액티비티는 애플리케이션이 시작될때 자동으로 시작될 수 있는 액티비티가 된다.
		<intent-filter>
			<action android:name="android.intent.action.MAIN" />
			<category android:name="android.intent.category.LAUNCHER" />
		</intent-filter>
		
14-2]인텐트의 종류

	1)명시적 인텐트:다른 액티비티 클래스 이름을 알고 있을때 사용하는 인텐트로
	                즉 명시적으로 액티비티 이름을 인텐트 생성시 지정한다.

			생성방법]
			new Intent(컨텍스트,메시지를 전달하거나 화면전환할 클래스명.class);
			예]new Intent(Context,AnotherActivity.class);

	2)암시적 인텐트:전달하는 메시지를 실행할 수 있는 어플리케이션이라면 어떤 어플리케이션이라도 상관없을때 즉
	                호출하려는 컴포넌트가 정해져 있지 않을때 사용하는 인텐트이다.

			생성방법]
			new Intent(액티비티 액션,데이타 URI);
			예]new Intent(Intent.ACTION_DIAL,Uri.parse("tel:01012345678"));

	
	

	3)인텐트 전달 및 수신 방법

		3-1)인텐트 전달

			-인텐트 객체의 putExtras("키값",값)메소드로 데이타 저장
			
			-startActivity(인텐트) 혹은 startActivityForResult(인텐트,요청코드)메소드로 인텐트 전달

			 예]
			  Intent intent = new Intent(this, 화면전환할 액티비티클래스명.class);
			  intent.putExtras("name", "홍길동");			
			  startActivity(intent);


                         ※ 인텐트를 전달한 메인 액티비티쪽에서 어떤 결과값을 받지 않을때는 startActivity(인텐트)메소드 그리고
                            어떤 결과값을 받고 싶다면  startActivityForResult(인텐트,요청코드)메소드 호출

			  ※요청코드는 0이상으로 설정, 0 미만으로 설정시 값을 받지 못한다

			    [결과값 받을 때 처리 순서]

			    -인텐트 전달하는 쪽에서는 startActivityForResult()메소드 호출하고
			     onActivityResult(int requestCode, int resultCode, Intent data)를 오버라이딩한다.

			     예]
			       @Override
				    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
					super.onActivityResult(requestCode, resultCode, data);
					if(requestCode==CALLER_REQUEST_CODE){
						if(resultCode == RESULT_OK){
						    textView.setText(data.getStringExtra("키값"));
						    
						}
					}
				    }


		3-2) 인텐트 수신

			    -인텐트를 수신하는 쪽에서는 getIntent()메소드를 호출하여 전달된 값을 받을 수 있다

			    예]
				Intent intent = getIntent();
				String name = intent.getStringExtra("name");
				
			
			    [결과값을 다시 호출한 쪽으로 전달 할때 처리 순서]
			     
			     - 인텐트 객체를 새롭게 생성하거나 getIntent()로 얻은 기존 객체를 이용해  리절트 코드와 함께 
			       인텐트를 setResult(리절트코드,인텐트)메소드에 인자로 넣어 호출한다. 그러면 호출한 쪽의 onActivityResult()메소드가 호출된다.
				
				예]
				 Intent intent = new Intent(this,MainActivity.class);
				 intent.putExtra("키값",다시 전달할 데이타);
				 //RESULT_OK는 Activity의 상수로 보통 리절트 코드로 많이 사용한다,그러나 사용자 정의 상수도 가능하다 
				 setResult(RESULT_OK,intent);
				 finish();
			    


		※DDMS(Dalvik Debug Monitoring Service)
		  AVD(Android Virtual Device)나 실제 안드로이드 폰 내의 폴더와 파일에 접근하는 기능을 제공
		  실제 단말기가 있는 것 같은 SMS보내기,GPS좌표 보내기등의 기능을 제공해준다.
		  주의 사항은 DDMS는 AVD의 내부를 살펴보는 개념이으로 먼저 AVD를 실행한 후에 DDMS를 실행 시켜야 한다
		  안드로이드 스튜디오에서는 상단 아이콘 메뉴중 안드로이드 로봇 모양의 Android Device Monitor클릭
	

[15.Fragment]@@@

	-액티비티가 하나의 화면을 구성 하듯이 
	 Fragment는 액티비티내에서 동작하는 하나의 화면이다.
	 허니콤(3.0 API레벨11)에서 지원하기 시작했으며,
	 태블릿과 같은 큰화며을 효율적으로
	 다루기 위한 유연한 UI구성을 위해 
	 액티비티와 뷰 중간쯤의 위치에 Fragment 클래스가 추가되었다.
         
	-Fragment는 Activity 와 비슷한 LifeCycle을 가진다. 
	-Fragment는 하나의 Activity에서 다수의 Fragment를 사용할 수 있다. 
	-Fragment는 Activity에서만 존재하며 단독으로 실행 될 수 없는 구조이다. 
	-Fragment는 Activity 위에서만 존재하기 때문에,
	 다수의 Fragment를 동시에 뛰울때 메모리가 문제가 될 수 있으므로 
	 너무 복잡한 구조는 지양해야 한다. 
	



15-1]프래그먼트를 액티비티에 추가하는 두가지 방법

	1)액티비티의 레이아웃 파일에 fragment를 선언
	
	  가]layout폴더에 fragment태그에 위치시킬 
	     프레그먼트 레이아웃(.xml) 작성
	  나]액티비티 내에 Fragment를 상속받은 내부 정적 클래스 작성 하거나 
	    별도의 외부 클래스로 작성후 onCreateView()오버라이딩
	        가]에서 작성한 레이아웃 파일 인플레이트 
	   
	  다] 액티비티 레이아웃 파일에 fragment태그로 프래그먼트 붙임.
	      fragment태그의 class속성에 
	      나]에서 작성한 내부 정적 클래스 지정.또한 fragment태그에
	      id속성 필수로 설정
	


	2)자바코드로 프래그먼트를 추가
	
	   가]layout폴더에 프레그먼트용 레이아웃(.xml) 작성
	   나]Fragment를 상속받은 프레그먼트 클래스(내부 혹은 별도의 외부클래스) 작성 후 
		onCreateView()오버라이딩  
		가]에서 작성한 레이아웃 파일 인플레이트 
	   다]액티비티에 자바 코드로 프레그먼트 붙임
		(1) 나]에서 만든 클래스 객체 생성
		(2) getFragmentManager()메소드로 FragmentManager  생성
		(3) FragmentManager객체의 beginTransaction()메소드로 FragmentTransaction 객체 생성
		(4) FragmentTransaction객체의  replace(프레그먼트 객체를 위치시킬 메인 레이아웃의 리소스 아이디, 나]에서만든 객체)
		(5) FragmentTransaction객체의 commit()메소드 호출


	※Fragment를 상속받은 내부 클래스는 
	  반드시 정적 클래스로 구성해야 한다.
	  프래그먼트를 상속받은 클래스는 
	  기본 생성자가 반드시 있어야 한다.
	  왜냐하면 액티비티의 상태에 따라 
	  프래그먼트가 복원될때 기본 생성자로 인스턴스화 되기때문에.....
	  그래서 인자 생성자는 피해라.....

	3)프래그먼트의 생명주기

		액티비티 시작                                       프래그먼트 시작
	--------------------------------------------------------------------------------------------
		onCreate()    -------------------> onAttach():프래그먼트가 액티비티와 연동 되었을때
						      ↓
                       					    onCreate():프래그먼트가 생성될때
						      ↓
						    onCreateView():프래그먼트를 구성하는 뷰를 생성하기 위해 호출
						      ↓
onRestart()-->  onStart()     <---------------------onActivityCreated():액티비티의 onStart()메소드가 호출되기 바로직전에 호출
		   |
↑		   |
 |		   +------------------------------->onStart():프래그먼트가 사용자에게 보여지기 적전  
 |		                                       |
 |						       |
 |		onResume()    <------------------------+
 |                  |
 |		   |
 |		   +------------------------------->onResume():프래그먼트가 보이고 사용자와 상호작용 할 수 있을때
 |
 |		   ..............................앱이 실행됨......................................................
 |		                                       |
 |						       |
 |						       ↓
 |              onPause()     <--------------------onPause():사용자와 상호작용 할 수 없을때
 |                 |
 |		   |
 |		   +------------------------------>onStop():프래그먼트가 중지 되엇을때
 |		                                       |
 |						       |
 <--------------onStop()      <------------------------+
                   |
		   |
		   +------------------------------>onDestoryView():프래그먼트를 구성하는 뷰가 제거될때 호출
		                                        ↓
					           onDestroy():프래그먼트를 더 이상 사용할 수 없을때
						        ↓
	        onDestory()   <-----------------------onDetach():프래그먼트가 액티비티와 연동이 끊어질때
                                                    

----------------------------------------------------------------------------------------------------------
            액티비티 종료                              프래그먼트 종료



액티비티와 프래그먼트는 라이프사이클을  같이한다.
생성은 액티비티 먼저, 죽음은 프래그먼트 먼저


[16. 안드로이드 파일 I/O]@@@



	1)내장 메모리 파일을 읽고 쓰기(내장 메모리-읽기/쓰기 가능)

		-내장 메모리의 위치 : /data/data/패키지명/files폴더
		-파일 읽기:
		        FileInputStream Context객체.openFileInput("파일명",파일권한)메소드 사용
		-파일 쓰기:
			FileOutputStream Conetxt객체.openFileOutput("파일명",파일권한)메소드 사용

			※openFileXXXX()계열에 파일 경로 설정시 
			  String타입인 경우 내장 메모리의 파일 절대 경로 생략
			  단,File객체로 설정시에는 절대 경로 지정
			  예]
			  openFileInput("파일명만"); 혹은 
			  openFileInput(new File("/data/data/패키지명/파일명"));

		-파일권한
		 ※파일을 읽고 쓰기시에는 보안을 고려해 아래 두 모드 사용 권장
		 Activity.MODE_PRIVATE:해당 어플리케이션에서만 사용가능한 파일 객체 모드
		 Activity.MODE_APPEND:해당 어플리케이션에서만 사용가능하고 추가모드
		 ※아래 권한은 보안문제로  API 17에서 Deprecated됨. 
		 사용은 가능하나 권장하지는 않는다.
		 Activity.MODE_WORLD_READABLE:모든 어플리케이션에서 읽기 가능한 파일
		 Activity.MODE_WORLD_WRITEABLE:모든 어플리케이션에서 쓰기 가능한 파일


		 -getDir()로 디렉토리 생성후 자바IO이용하기
                  1. File getDir("디렉토리명",Activity.MODE_PRIVATE);
		     DDMS 보면 /data/data/패키지명/app_디렉토리명 라는 디렉토리가 생성됨
		  2. getAbsolutePath()로 절대 경로 얻고 

		  3. 생성할 File객체 생성후 자바 IO작업
		  예]

		    // 내장 메모리에 디렉토리 생성
                    File mydir = getDir("mydir",Activity.MODE_PRIVATE);
                    //1]에서 getDir("mydir",Activity.MODE_PRIVATE);라고 설정시
                    // DDMS오 보면 /data/data/패키지명/app_mydir라는 디렉토리가 생성됨
                    String filePath= mydir.getAbsolutePath();
                    //3]생성할 실제 파일
                    File file= new File(filePath+File.separator+"data.txt");
                    //자바 IO이용
                    FileOutputStream fos = new FileOutputStream(file);
                    fos.write(editText.getText().toString().getBytes());
                    fos.close();
	
		
	2) res/raw폴더 파일을 읽기(내장 메모리-읽기 전용)

		- 프로젝트의 res밑에 raw폴더 생성후 파일 저장
		  ※res폴더 마우스 우클릭 ->new ->
		  Android resource director->
		  Directory name과 Resource Type을 모두 raw로 지정
		- 읽기 전용으로만 사용되며 쓰기는 할 수 없다. 
		  ※쓰기는 내장 메모리나 SD카드에 저장된 파일만 가능하다.

		-파일 읽기:
			
			InputStream getResources().openRawResouece()
			//raw디렉토리에 있는 리소스를 읽기 위해 사용되며,values디렉토리에 있는
			                                            
								    //문자열이나 색상 리소스는 읽을 수 없다.


	3)SD카드에 파일을 읽고 쓰기(외장 메모리-읽기/쓰기 가능)
		
		- 제한된 공간의 내장 메모리보다 
		  훨씬 큰 공간을 사용할 수 있으며 확장성도 뛰어나다
		※AVD 에 장착된 SD카드 확인
			안드로이드 스튜디오의 Tools메뉴->Android->
			AVD Manager실행 혹은
			핸드폰 모양의 상단 아이콘 AVD Manager 실행
			혹은 안드로이드 SDK가 설치된 디렉토리 \Android\SDK밑에 AVD Manager.exe실행(권장)

		-SD카드 메모리의 위치 : /storage/sdcard(또는 /mnt/sdcard) 
		 ※킷캣 이후 버전에서는 /storage/sdcard사용. 
		 또한 SD카드를 읽기만 해도 매니페스트 파일에 퍼미션을 
		 추가해야 한다.

		-파일 읽고 쓰기:자바의 IO클래스 사용
			예]
			
			FileInputStream fis = new FileInputStream("/sdcasrd/파일명");// /storage/sdcard/파일명도 가능
			byte[] txt = new byte[fis.available()];
			fis.read(txt);
			editText.setText(new String(txt));
			fis.close();
			//텍스트 파일인 경우 FileReader가 유리하다.
			

		※SD카드 사용시에는 매니페이스 파일에 아래 권한 추가
		<use-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>

	※//루트 디렉토리 얻기]
           Environment.getDataDirectory().getAbsolutePath(): 앱의 데이타 디렉토리 루트(예]  /data)
           Environment.getRootDirectory().getAbsolutePath(): 안드로이드 시스템의 디렉토리 루트(예]/system)
           Environment.getExternalStorageDirectory().getAbsolutePath():SD카드의 루트 디렉토리(예]/storage/sdcard)

	※안드로이드 기본 인코딩은 UTF-8 임으로 
	  내장/raw폴더/SD카드에 텍스트 파일 저장시에는
	  UTF-8로 인코딩하여 저장하는 것이 좋다.


[17.어댑터 뷰]@@@

 - 리스트 뷰,그리드 뷰,스피너,갤러리등을 총칭해서 어댑터뷰라 함.
   상기의 위젯들은 아이템들을 표시하기 위해 Adater로부터
   데이타들을 제공받기때문에 어댑터 뷰라함.
   즉 데이타 원본을 어댑터라는 객체가 상기 위젯과 연결을 해줘야
   데이타들이 각각의 위젯의 UI대로 화면에 표시해줌.

17-1]계층도

		 View
		   ^
		   |
		   |
		ViewGroup
		   ^ 
		   |
		   |
		AdapterView  <-- AbsListView <---ListView <--- ExpandableListView
		    ^                	       ^
		    |		       |
		    |		       +--------- GridView
		    |
		    +-------------AbsSpinner <--- Spinner
				       ^
				       |
			               +----------Gallery


		Adapter(인터페이스)
			^
			|
			|
		+------------------------+
		|                        |
		|                        |
	ListAdapter                SpinnerAdapter(인터페이스)
		|                        |
		|                        |
		+------------+-----------+
			     |
			     |
			 BaseAdapter(추상 클래스)
			     |
			     |
	+--------------------+-----------------------+
  ArrayAdapter          CursorAdapter        SimpleAdapter



17-2]주요 어댑터 뷰 분류


--------------------+----------------------------+-----------------------------------+---------------------------------------------
어댑터뷰            |   아이템 뷰(convertView)   |    적용 어댑터    	             |    데이터원본
--------------------+----------------------------+-----------------------------------+---------------------------------------------
Spinner	            |   TextView                 |     ArrayAdapter                  |	  배열 혹은 컬렉션
--------------------+----------------------------+-----------------------------------+---------------------------------------------
ListView            |	TextView                 |     ArrayAdapter                  |    배열 혹은 컬렉션
--------------------+----------------------------+-----------------------------------+--------------------------------------------
GridView            |   ImageView                |     커스텀 어댑터                 |    배열 혹은 컬렉션
--------------------+----------------------------+-----------------------------------+---------------------------------------------
Gallery             |   ImageView	            |     커스텀 어댑터                 |    배열 혹은 컬렉션
--------------------+----------------------------+-----------------------------------+--------------------------------------------


※Gallery는 API레벨 16에서 Deprecated됨.
※각 아이템을 표시하는 뷰는 커스텀(사용자 정의) 뷰 적용 할 수도 있음.
적용시에는 주로 BaseAdapter를 상속받은
  커스텀 어댑터를 구현.
※각 어댑터뷰의 아이템 클릭시에는 setOnItemClickListener를 사용하나 
  Spinner는 setOnItemSelectedListener를 사용
※아이템을 표시하기위해 안드로이드 시스템에서 제공해주는 레이아웃 사용시 android.R.layout로 시작하는 레이아웃 적용
  해당 레이아웃 파일은 안드로이드 SDK설치시 platforms\android-버전\data\res\layout폴더에 xml파일 형태로 정의 되어 있음


17-3]어댑터 뷰와 데이타 어댑터와의 관계


	어댑터 뷰(ListView)         <------------------>  어댑터 <----------------------------------데이타 원본(배열 혹은 컬렉션)                   
        (Parent)                                         (convertView)



	1)어댑터뷰에서 어댑터에 아이템의 갯수를 요청하면 어댑터는 데이타원본의 총 아이템(데이타)수를
	  어댑터 뷰에 전달한다.(getCount())
	2)어댑터 뷰가 0번째 Position에 대한 아이템의 뷰를 어댑터에 요청하면 어댑터는 데이타원본에 있는 데이타를 convertView에 맞게
	  데이타를 설정해 어댑터 뷰에 전달한다.(getView())
	  이와 같은 방법으로 한 하면에 뿌려질 아이템 갯수만큼 반복한다.
	3)만약에 사용자가 화면을 아래로 스크롤한다면 다시 2)번과정을 반복하여 다음 화면에도 아이템을 화면에 뿌려준다.



17-4]리스트 뷰

	- 텍스트형태의 목록을 표시하는 뷰로 가장 많이 사용하고 활용도가 높은 어댑터 뷰


	[리스트 뷰 생성 방법]	   

	-방법1]ListActivity 상속받는 경우

	1. 기본 리스트뷰 생성(텍스트형태의 순수 목록만 표시할때)]
		가)레이아웃용 xml파일 및 setContentView() 불필요
		나)Activity대신 ListActivity상속(ListView를 포함하고 있는 액티비티)
		다)리스트 뷰 객체는  findViewById가 아닌 this.getListView()로 얻는다
		라)어댑터 연결시 리스트뷰.setAdapter()대신 this.setListAdapter()사용
		마)아이템클릭 이벤트 처리시에는 리스트뷰.setOnItemClickListener()가 아닌 onListItemClick()메소드 오버라이딩해서 구현

	2. 기본 리스트뷰에 다른 위젯 추가]
	   
	  가)xml레이아웃에 ListView 및 다른 위젯 추가. 단, ListView의 아이디는 반드시 android:id="@android:id/list"로 설정.
	  나)메인 액티비티에서 setContentView()메소드로 레이아웃 전개


	-방법2]Activity 상속받는 경우
	
	가)레이아웃용 xml파일 작성 및 setContentView() 로 레이아웃 전개
	나)ListActivity대신 Activity상속
	다)리스트 뷰 객체는  findViewById로 리스트 뷰 객체 얻기
	라)어댑터 연결시 리스트뷰.setAdapter()로 연결
	마)아이템클릭 이벤트 처리시에는 리스트뷰.setOnItemClickListener()로 구현


	※어댑터에 데이타 연결
	방법1] arrays.xml파일을 values폴더에 생성후 ArrayAdapter.createFromResource(컨텍스트,배열 리소스 아이디,텍스트뷰 리소스 아이디)메소드로 데이타 연결
	방법2] 데이타를 자바 소스에서 배열이나 컬렉션으로 준비후 new ArrayAdapter<String>(컨텍스트,android.R.layout로 시작하는 안드로이드 시스템 제공 레이아웃,배열 혹은 컬렉션);




	-방법3] 커스텀 뷰 적용하는 경우
	
	Step1]layout폴더에 리스트뷰의 아이템 항목에 커스텀 뷰를 적요하기 위한 XML파일 생성
	Step2]리스트뷰의 아이템 항목을 구성하는 자료구조 클래스 생성
	Step3]BaseAdapter를 상속받은 Adapter클래스 생성
	
	나머지 리스트뷰와 어댑터를 연결하는 과정은 ListActivity를 상속받거나 Activity를 상속받아 리스트뷰를 구성하는 절차와 동일하다




17-5] 스피너

	-콤보박스 모양의 뷰.모바일처럼 작은 화면의 UI로 적당하나  2 DEPTH를 통해서 선택이되고 하나의 아이템만 선택되는 점이 리스트뷰와의 차이점이다
        -simple_spinner_item이 기본 레이아웃(통상적으로 많이 씀)
	-simple_spinner_dropdown_item 레이아웃는 아이템간 간격이 넓어 터치하기에 편함.
	-아이템 클릭시 이벤트 처리시에는 setOnItemClickListener가 아닌  setOnItemSelectedListener를 사용


17-6]그리드 뷰

	- 표형태로 위젯을 표시하는 어댑터 뷰로 
	 사진이나 그림을 테이블모양으로 배치하는데 주로 사용.
	- 속성중 numColumns는 필수로 열 개수를 지정한다
	  예]아이템 수가 총 10개이고 numColumns가 3으로 설정되었다면 행은 3,3,3,1임으로 총 4개의
	     행이 생긴다.테이블모양으로.....



[18. SQLite]@@@

	-SQLite공식 사이트:http://www.sqlite.org
    
	-안드로이드 SDK에 내장된 경량의 관계형 데이타베이스로 
	 모바일 환경에 최적화된 데이타 베이스
	-파일 기반의 데이타 베이스(파일형태로 데이타베이스를 컨트롤)
	-SQLiteOpenHelper라는 클래스로 데이타 베이스 생성 및 테이블 생성 및 테이블 변경등의 작업
	-SQLiteDatabase 클래스의 메소드(예]execSQL("쿼리문"))로 CRUD작업
	-ContentValues클래스는 레코드 하나를 나타내는 자료구조




18-1] SQLite 기본 사항

	[명령 프롬프트에서 SQLite를 실행]

	※명령 프롬프트에서 SQLite를 실행하려면 AVD가 실행되고 있어야 한다.
	-2.2버전까지는 adb shell이 안드로이드SDK설치된 디렉토리\tools 에 있으나 
	 2.3이후부터는 안드로이드SDK설치된 디렉토리\platform-tools에 있음
       

	※SQL문은대소문자를 구분하지 않는다.또한 모든 SQL문의 끝에는 세미콜론(;)을 붙여야 한다.
	  SQLite 자체명령은 소문자로 써야 하고 시작시 "."을 붙이며 끝에 세미콜론을 붙이지 않는다.
	   
	  

	  .table:테이블 목록 표시  // SELECT * FROM tab;
	  
	  
	  .schema 테이블명:테이블의 생성 SQL문 표시 //desc table 명
	  
	  
	  .header on:SELECT문으로 조회시 컬럼명을 표시한다.  //해야 보기 편하다.
	  
	  .mode column:SELECT문으로 조회시 컬럼모드로 출력해준다.즉 컬럼명과 데이타 사이에 구분선을 넣어준다.
	  .exit:SQLit를 종료


	[데이타 베이스 생성]
	※에뮬레이터에 반드시 앱을 설치후 접속
	 dos>adb shell(엔터) -- 리눅스 shell 상태로 접속
     	 # run-as 패키지명  -- 패키지로 들어감
	 # ls
	 # mkdir databases
	 # ls
	 # cd databases
	 # pwd
	 # sqlite3 mydb.db(데이타베이스명)
	 
	 ※데이타베이스 생성후 테이블을 만들어야 /data/data/도메인/databases안에 데이타베이스가 생기는 것을 확인 할 수 있음(DDMS에서)
	  sqlite>create table ~(엔터)
	  sqlite>.table  명령어로 목록 확인ㅇ
	  sqlite>.exit  로 종료
	  다시 접속시에는
	  # sqlite3 데이타베이스명(엔터)
	
	  

	[테이블의 생성]
	
	Create [TEMP] TABLE <테이블명> (Column정의, [테이블제약]);
 
	-TEMP(또는 TEMPORARY) 키워드를 지정하면 임시 테이블을 작성할 수 있다.
	-이 테이블은 데이터베이스를 close했을 때에 자동적으로 삭제된다.
	
	[SQLite에서 지원하는 컬럼 타입] 
	※데이타 타입은 참조용일뿐이다.
	  레코드를 입력할때 어떤 타입의 레코드 뿐만 아니라
 	  자료형 크기보다 큰 데이타를
	  입력해도 오류가 나지 않는다.
	  왜냐하면 SQLite는 컬럼별로 입력되는 데이타 타입을 다르게 할 수 있다.

	text- 문자열
	integer - 정수
	real - 부동소수
	boolean - true 또는 false
	datetime - 날짜
	

	[테이블의 작성 예]


	Create table Member(

	_id integer primary key autoincrement,

	name varchar(10) not null ,

	tel char(12) not null default 'unknown',

	unique (name, tel),

	check(length(tel)>=3));

	); 

	_id: primary key라는 걸 알려주기 위해 일반적으로 _id형태로 표시

	


	[테이블 삭제]

	drop table 테이블명; 

	[테이블 수정]

	이름변경-alter table 테이블명 rename to 새로운 테이블명; 

	column추가-alter table 테이블명 add column 컬럼 정의;

	
	[데이타 입력/조회 /수정/삭제]
	표준 SQL문 사용.
	단,문자열은 ' 나 "으로 감싸면 된다.
	또한 데이타 삭제시에는 반드시 delete 다음에 from을 추가 해야 한다.

	[SQLite의 내장 함수]

	min(X,Y,…,)-최소값을 반환
	max(X,Y,…,)-최대값을 반환
	typeof(X)-데이터의 형을 반환
	length(X)-문자열의 길이를 반환
	substr(X,Y,Z)-X의 문자열의 Y번째에서 Z문자의 길이의 문자열을 반환
	abs(X)-절대값을 반환
	round(X,Y)-실수 X를 소수점 Y+1자리에서 반올림
	upper(X)-대문자로 변환
	lower(X)-소문자로 변환
	coalesce(X,Y,z…,)-최초의 NULL이 아닌 값을 반환
	hex(X)-문자열을 16진수 표기로 반환
	random()-Radom한 값을 반환	
	nullif(X,Y)-2개의 값이 다르면 최초의 값을 반환. 같다면 NULL을 반환
	sqlite_version()-SQLite의 버전을 반환	
	last_insert_rowid()-마지막에 삽입한 레코드의 ID를 반환
	sum(X,Y,…,)-NULL이 아닌 행의 값의 합계를 반환.행이 없는 경우 NULL을 반환
	total(X,Y,…,)-NULL이 아닌 행의 값의 합계를 반환.를 반환.행이 없는 경우 0
	avg(X,Y,…,)-NULL이 아닌 행의 값의 평균을 반환.행이 없는 경우 NULL을 반환
	count(X)-그륩 안에서 X가 NULL이 아닌 행의 행수를 반환합니다.
	count(*)-그룹 별의 행수를 반환합니다.

	datetime():
	           현재시간 얻기
		   GMT기준으로 시간 표시.우리나라는 GMT보다 9시간 빠름으로	            
	           select datetime('now','+9 hours');

		   예] 년월일 시 분 추가시
		   select datetime('now','+9 hours','+1 minute','+1 year','+1 month','+1 day')



	※트랜잭션처리-반드시 commit;이나 rollback명령어 사용시는
	               begin;명령어로 트랜잭션을 시작을 알린다.
	sqlite>begin;
	sqlite>delete from 테이블명;
	sqlite>rollback;   혹은 commit; 

	sqlite는 begin;없이 rollback;   혹은 commit; 실행시
	cannot rollback - no transation is active
	혹은
	cannot commit; - no transation is active 에러발생

	단,sqlite는 insert,update,delete문에 대해 자동커밋이 이루어진다.
	(오라클은 콘솔에서 insert,update,delete시 반드시 commit;해줘야
	  실제 테이블에 반영됨)

18-3] 안드로이드의 API	
	
	-SQLiteOpenHelper- SQLiteOpenHelper를 상속 받아서 데이터베이스 및 테이블을 생성하도록 재정의 하는 데 사용하는 클래스.
			   SQLiteOpenHelper클래스의 getWritableDatabase()메소드는 SQLiteDatabase타입을 반환해준다.

	-SQLiteDatabase클래스-CRUD작업을 제공해 주는 클래스
	                      exeSQL() 혹은 rawQuery()등으로 SQL문을 실행한다.
	-Cursor : 데이터베이스나 내용 제공자(Content Provider)의 데이터를 쿼리하여 가져올 때 사용되는 클래스로 결과값을 가지고 있는 포인터다.

	-각 클래스의 주요 메소드]
	-----------------------------------------+------------------------------------------+--------------------------------------------------
	클래스(혹은 인터페이스)                  |  메소드                                  |          주요 기능
	-----------------------------------------+------------------------------------------+--------------------------------------------------
	SQLiteOpenHelper                         | 생성자                                   | 데이타 베이스 생성
	                                         +------------------------------------------+---------------------------------------------------
						 | onCreate()                               | 테이블 생성
						 +------------------------------------------+--------------------------------------
						 | SQLiteDatabase getReadableDatabase()     |  읽기 전용으로 DB열기
						 +------------------------------------------+--------------------------------------
						 | SQLiteDatabase getWritableDatabase()     |  읽고/쓰기용으로 DB열기
	-----------------------------------------+------------------------------------------+--------------------------------------
	SQLiteDatabase                           | void execSQL()                           | Insert/Delete/Update실행
	                                         +------------------------------------------+--------------------------------------
						 | Cursor query(),rawQuery()                | Select문 실행
						 +------------------------------------------+--------------------------------------
						 | close()                                  | DB닫기
	-----------------------------------------+------------------------------------------+--------------------------------------
	Cursor                                   | moveToFirst()                            | 커서 첫 행으로 이동
	                                         +------------------------------------------+--------------------------------------
						 | moveToLast()                             | 커서 마지막 행으로 이동
						 +------------------------------------------+--------------------------------------
						 | moveToNext()                             | 다음 레코드로 이동
						 +------------------------------------------+--------------------------------------
						 | moveToPrevious()                         | 이전 레코드로 이동
						 +------------------------------------------+--------------------------------------
						 | moveToPosition()                         | 특정 레코드로 커서 이동
						 +------------------------------------------+--------------------------------------
						 | isFirst()                                | 커서가 첫번째 레코드에 위치하는지를 반환
						 +------------------------------------------+---------------------------------------
						 | isLast()                                 | 커서가 마지막 레코드에 위치하는지를 반환
						 +------------------------------------------+----------------------------------------
						 | isBeforeFirst()                          | 커서가 첫번째 레코드의 앞에 위치하는지를 반환
						 +------------------------------------------+------------------------------------------
						 | isAfterLast()                            | 커서가 마지막 레코드의 뒤에 위치하는지를 반환
	-----------------------------------------+------------------------------------------+-----------------------------------------

	
	
	
	
	-CursorAdapter :BaseAdapter를 상속받은 클래스로 데이타베이스의 
	                데이타를 리스트뷰에 바인딩 할때 주로 사용한다.
	                CursorAdater는 일반 어댑터와 달리 
			커서라는 용어처럼 데이타베이스 또는 
			컨텐트 프로바이더의 쿼리 문장을 통해
                        얻은 커서(Cursor) 객체와 리스트뷰를 연동한다. 
			단,생성자 구현과 bindView() 메서드 그리고 
			newView() 메서드를 오버라이딩해야 한다.
			
			

			newView() : 리스트뷰에 뿌려줄 레이아웃을 얻는후 반환한다
			bindView() : 커서에 있는 데이타를 뷰에 설정한다

			-커서어댑터 클래스 내 bindView() 메서드와 newView() 메서드는 기능상으로 BaseAdapter 클래스의 getView() 클래스와 유사하다
			 newView() 메서드로 뷰를 생성하고 bindView() 메서드로 커서의 데이타와 뷰를 연결시켜준다는 점에서 차이가 존재한다


			※CursorAdapter를 쓸때 사용하는 Cursor에는 '_id'인 컬럼이름이 존재해야만 한다.

	-SimpleCursorAdapter: CursorAdapter를 상속받는 클래스로 
	데이타베이스 또는 컨텐트 프로바이더의 쿼리 문장을 통해
	                      얻은 커서(Cursor) 객체와 레이아웃을 
			      쉡게 연동시켜주는 클래스
			      (즉 CursorAdpater를 상속받아 newView()나 bindView()를 오버라이딩 할 필요 없음)

	 SimpleCursorAdapter(Context context, int layout, Cursor c, String[] from,int[] to, int flags)
    
         context : 리스트뷰가 속해 있는 Context
	 layout:리스트뷰 하나의  아이템을 정의한 뷰 레이아웃 파일의 아이디.레이아웃 파일의 뷰들(위젯)은 적어도 "to"에 정의된 위젯의 아이디를 포함하고 있어야 한다.
         c :데이타베이스의 커서로 커서가 준비가 안되엇다면 null 지정가능
         from : UI에 바인딩 될 데이타를 나타내는 컬럼명 배열 . 
	        커서가 준비가 안되엇다면 null 지정가능.
         to : "from" 매개변수에 정의된 컬럼명에 표시할 뷰의 리소스 아이디 배열.
	      ※이들 뷰는 모두 TextView여야한다.
	       커서가 준비가 안되엇다면 null 지정가능.

        flags:  어댑터의 행동을 결정하는 상수, CursorAdapter(Context, Cursor, int) 참조



	※CursorAdapter사용시 데이타 변경 통지 방법
	  
	  커서어댑터.getCursor().requery();
	  커서어댑터.notifyDataSetChanged(); 이나 requery()메소드가 API level 11에서  deprecated되었다

	  그래서 changeCursor(cursor)메소드 사용. 여기서 cursor는 변경된 데이타를 담고 있는 cursor객체이다

	  커서어댑터.changeCursor(cursor);
	  커서어댑터.notifyDataSetChanged();

	
	  예]
	 //모든 데이타 얻어오기]
	 private Cursor selectList(){

		//Cursor cursor=sqlLite.rawQuery("SELECT * FROM MEMBER ORDER BY _ID DESC",null);
		Cursor cursor=sqlLite.query(TABLE_NAME,new String[]{"_id","user","name","age","postdate"},null,null,null,null,"_ID DESC");

		return cursor;

	}

	 //데이타 변경시 변경된 데이타 리스브뷰에 반영하기]
	private void notifySetDataChanged(){
		//모든 데이타 조회]
		cursor = selectList();
		adapter.changeCursor(cursor);
		adapter.notifyDataSetChanged();
	}
	

18-4.안드로이드에서 SQLite 활용] 

	

	Step1]SQLiteOpenHelper를 상속받은 클래스 작성
		
		생성자 구현:데이타베이스 생성
		onCreate() 오버라이딩:데이타 베이스 파일 생성.데이타베이스 파일이 만들어 질때 딱 한번만 호출됨(getWritableDatabase()혹은 getReadableDatabae()호출시)
		onUpgrade():데이타베이스 버전을 바꾸고자 할때 호출.스키마 버전이 바뀐 경우 새롭게 테이블을 생성하도록 오버라이딩

	Step2]layout폴더에 메인 레이아웃 및 리스트뷰에 표시할 뷰 레이아웃 작성

	Step3]CursorAdapter를 상속받아 커스텀 어댑터를 구현하거나 SimpleCursorAdapter를 사용해서 쉽게 레이아웃과 연동
		
		-CursorAdapter를 상속받는 경우
		 생성자 및 newView() 및 bindView()메소드 오버라이딩

	Step4]MainActivity에서 
		
		1)SQLiteOpenHelper를 상속받은 클래스 객체 생성후 getWritableDatabase()메소드 호출
		2)SQLiteDatabase객체의 query()나 rawQuery()메소드로 SELECT 쿼리 실행후 Cursor객체를 얻는다
		3)커스텀 어댑터나 SimpleCursorAdapter객체 생성. 생성시 2)에서 얻은 커서 전달
		4)메인 레이아웃에 있는 리스트뷰 객체 얻은후 3)에서 생성한 어댑터 객체와 연동


		
		


※SQLite GUI 도구
	-http://sourceforge.net에서 SQLite로 검색->DB Browser for SQLite클릭->https://github.com/sqlitebrowser클릭

	에뮬레이터에 만들어진 SQLite DB파일 열기
	1. DDMS에서 보안상의 이유로 에뮬에이터에서 PC로 다운받거나
	   업로드 불가(접근불가)
	2. View - Tool Window - Device FileExplore 오픈
	3. 현재 앱의 /data/data/패키지/ 이 아래서 만들어 놓은 데이타베이스 
	    파일을 PC로 다운로드(SAVE AS로)


[19. 스레드]@@@

	 - 스레드는 프로세스내에서 동작하는 작은 실행 단위이며, 
	   경량 프로세스라고 부르기도 한다.
	 - 사용자 인터페이스를 관리하는 
	   스레드인 UI스레드(혹은 메인 스레드라 함)가 관리하는 
	   UI는 다른 스레드가 임의로 접근할 수 가 없다
	 - 메인 스레드가 아닌 작업 스레드안에서 위젯의 
	    UI를 변경하면 응용 프로그램 중지된다.
	   UI스레드(메인스레드)즉 위젯을 생성한 액티비티 안에서만 변경 가능.
	   단,프로그레스바 및 프로그레스바의 하위자식은 
	   예외적으로 변경이 가능하나 역시 프로그레스바도 UI 스레드안에서 변경하는것이 안정적이다.



19-1]Handler
	- 메인스레드 와 작업 스레드 간에 통신을 담당하는 객체.즉 메인스레드 내에 존재하면서 작업 스레드에서 UI스레드에 접근 할 수 있도록
          도와주는 클래스

	-다른 스레드는 UI스레드가 관리하고 있는 
	   메시지큐에 메시지(원하는 작업)를 전달해서 
	   UI스레드가 이를 처리하게 해야 한다

         -sendXXXX()메소드는 UI스레드에 메시지를 전달하는 메소드로 
	  이렇게 전달한 메시지는 핸들러객체의 handleMessage()메소드에 
	  전달되어 UI스레드상에서 처리 된다.

	 -Handler클래스의 메시지 전달 메소드-sendXXXX()

	      sendEmptyMessage(int what):what값만을 포함하는 메시지 전달.
	      sendEmptyMessageAtTime(int what,long uptimeMills):what값만을 포함하는 메시지를 uptimeMills시간에 전달한다
	      sendEmptyMessageDelayed(int what,long delayMills):what값만을 포함하는 메시지를 delayMills시간뒤에 전달한다.
	      sendMessage(Message msg):메시지 큐 뒤에 메시지 객체를 추가한다.
	      sendMessageAtTime(Message msg,long uptimeMills):메시지 객체를  uptimeMills시간에 전달한다
	      sendMessageDelayed(Message msg,long delayMills):메시지 객체를  delayMills시간뒤에 전달한다.

	-Message클래스의 상수 값

	      int arg1:전달할 숫자 데이타
	      int arg2:전달할 숫자 데이타
	      Object obj :전달할 객체
	      Messenger replyTo:응답을 받을 객체
	      int what:메시지를 구분하기 위한 코드(사용자가 직접 정의)



deprecated 됨
19-2]Handler를 이용한 UI 변경


	      방법1]
	      1)메인 액티비티에서 핸들러 객체 생성 및 handleMessage()오버라이딩
	        handleMessage()메소드안에서 UI변경
		예]
		      Handler handler = new Handler(){
				//handleMessage(Message msg)오버라이딩
				public void handleMessage(Message msg){
				       if(msg.what==1)
						textView.setText("텍스트 변경");
				}
		      };


	      2)작업 스레드의 run()메소드 안에서 핸들러 객체의 sendXXX()계열 메소드 호출
	      while(true){
			try{
				handler.sendEmptyMessgae(1);
				
				sleep(100);
			}
			catch(InterruptedException e){}

	      }

	      방법2]
	      1)메인 액티비티에서 핸들러 객체만 생성-handleMessage()오버라이딩 불필요
	       Handler handler = new Handler()

	      2)작업 스레드의 run()메소드 안에서 핸들러 객체의post(Runnable객체)계열 메소드 호출

		 handler.post(new Runnable() {
                    @Override
                    public void run() {
                        //이 안에서 UI변경]
                        textView.setText("텍스트 변경");
                    }
                });

19-3]runOnUiThread(Runnable객체 사용) 메소드로 UI변경
	
	-핸들러를 통하지 않고 UI스레드의 작업을 진행 할 수 있다. 
	즉, Handler객체를 선언하지 않아도 된다

	-작업 스레드의 run()메소드 안에서 runOnUiThread(Runnable객체 사용) 메소드 호출

	      runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        //이 안에서 UI변경]
                        tvThreadNumber.setText("스레드에서 1씩 증가:"+threadNumber);
                    }
                });



자주 사용한다.
19-4] AsnycTask

	-작업스레드에서 메인스레드의 UI를 접근하려면 Handler를 사용 했다.
	 새로운 Thread를 만들고, Handler를 만들어서 통신 하였다.
	 이러한 여러 가지의 작업을 Android OS에서는 AsyncTack 객체 하나로 
	 사용하기 쉽게 만들어 놓았다.
	 즉, 클래스 하나에 Thread와 Handler의 기능이 콜백 메서드로 모두 존재 한다. 

	-비 동기작업을 손쉽게 할 수 있도록 안드로이드1.5(API레벨 3)부터 제공하는 기능
        -자바에서 제공하는 스레드 사용하지 않고 구현.
        -어싱크테스크는 3개의 제너릭 타입(Params,Progress,Result)를 제공
        -제너릭 타입(실행시에 테이타 타입을 정할 수 있는 특수한 타입)은 
	  어싱크테스크를
         상속받은 클래스에서 오버라이딩한 메소드의 
	 매개변수 타입이 되거나 반환타입이 됨.
        -주요 4개 메소드
                Result doInBackground(Param...param ):별도 스레드로 동작해야 할 코드 
		                                      즉 스레드의 run()메소드에서 수행해야할 코드 작성
                void onPreExecute(): doInBackground()메소드 실행전에 선처리할 코드 작성
                void onPostExecute(Result result):doInBackground()메소드 왼료후 처리할 코드
                void onProgressUpdate(Progress... values):doInBackground()메소드가 동작하는 동안 주기적으로 반영해야할 코드(UI변경)
                void onCancelled(Result result):작업이 취소될 경우 처리할 코드
                
	AsyncTask<Param, Progress, Result> execute(Param... param):주어진 매개변수로 AsyncTask실행
        ※execute()메소드의 인자가 doInBackground()매소드의 인자로 전달된다.
        ※onProgressUpdate(Progress... values)메소드를 호출하기 위해서 doInBackground()메소드안에서 publishProgress()메소드 호출
        ※cancel()메소드(어떤 스레드에서나 호출가능)를 호출하면  doInBackground()매소드의 작업이 취소되며 onCancelled(Result result)메소드가 호출됨.
        ※doInBackground()매소드는 
	UI스레드(메인스레드)와는 별도의 스레드로 동작. 그외 메소드는 UI스레드에서 동작
        ※doInBackground()매소드에서 반환한 값은 onPostExecute와onCancelled에 전달된다.
        ※onProgressUpdate메소드에서 어떤 인자도 받지 않을 거라면 Void...param으로 선언

        
               
	    예]백그라운드로 원격에 있는 3개의 파일 다운로드 구현
	    new DownLoadTask().execute(url1,url2,url3);

	    class DownLoadTask extends AysncTask<URL,Integer,Long>{

		protected Long doInBackground(URL...url){
		    long totalByte=0;
		    for(int i=0; i <url.length;i++){
			totalByte+=다운로드로직메소드(url[i]);
			publishProgress((int)((i/(float)url.length)*100));//
		    }
		    return totalByte;
		}

		protected void onProgressUpdate(Integer... values){
		    진행율표시메소드(values[0]);
		}
		protected void onPostExecute(Long result){
		     Toast.makeText(getApplicationContext(),"총 "+result+"bytes 다운",Toast.LENGTH_SHORT).show();

		}

	    }



               
[20. XML파싱 및 JSON파싱]


20-1] XML 파싱


	-Parser:일련의 문자열을 의미있는 토큰으로 분해하고 이들로 이루어진 파스 트리를 만드는 과장
	-Parsing:원하는 데이타만 추출하는 과정


	---------------+------------------------------------------------------+------------------------------------------------+--------------------------------------------------------------------
	파싱 종류      | DOM(Document Object Model)파서                       | SAX(Simple API for XML) 파서                   | PULL 파서
	---------------+------------------------------------------------------+------------------------------------------------+---------------------------------------------------------------------
	파싱방법       | 문서를 객체 형태로 접근하는 트리기반의 방식          |  문서를 순차적으로 파싱하는 이벤트 기반의 방식 | 문서를 순차적으로 원하는 부분까지 파싱할 수 있는 이벤트 기반의 방식
	---------------+------------------------------------------------------+------------------------------------------------+---------------------------------------------------------------------
	장점           | 트리구조라 검색.수정.삭제가 용이함                   | 대용량.대규모 문서처리 가능 .DOM보다 더 적은   |  대용량.대규모 문서처리 가능.원하는 부분까지만 파싱 가능
	               | 코드 단순                                            | 메모리 사용                                    |  메모리 적게 사용
         --------------+------------------------------------------------------+------------------------------------------------+---------------------------------------------------------------------
	 단점          | 전체 무서를 다 읽어야 처리 할수 있기때문에           | 문서구조 파악불가.                             | SAX보다 속도 느림.문서구조 파악 불가
	               | 메모리 많이 사용.속도 느림.                          | 코드 복잡                                      |
         --------------+------------------------------------------------------+------------------------------------------------+---------------------------------------------------------------------
         선택기준      | 전체 문서 구조 파악 필요시                           | 문서구조 파악 필요 없을시                      | 문서구조 파악 필요 없을시(SAX보다 유리.왜냐하면 SAX는 
	               |                                                      |                                                | 잘 설계된 디자인을 갖고 있지 않음으로 코드가 복잡해지는 경향이 있음
	 --------------+------------------------------------------------------+------------------------------------------------+----------------------------------------------------------------------


20-2]PULL파서를 사용한 원격의 XML데이타 파싱


	-날씨정보 XML데이타 URL주소

	http://www.kma.go.kr->날씨->생활과 산업->서비스->인터넷->서울.경기도->RSS->http://www.kma.go.kr/weather/forecast/mid-term-rss3.jsp?stnId=109

	-파싱 절차]

	STEP1]원격의 XML데이타를 가져오기 위한 스레드 구성(AsyncTask사용)

	STEP2]doInBackground(String...urls)메소드에서 PULL파서를 이용해서 파싱
	
	        1)XmlPullParserFactory객체 생성		
			XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
		2)XML네임스페이스 사용 설정
			factory.setNamespaceAware(true);
		3)XmlPullParserFactory객체로 XmlPullParser 객체 얻기
	
			XmlPullParser xpp = factory.newPullParser();

		4)URL객체로 원격의 XML데이타 가져오기
			URL url=new URL(원격주소)
			InputStream is = url.openStream();
		5)XmlPullParser에 원격에서 가져온 데이타 설정
			xpp.setInput(is,"UTF-8");
		

		6)XmlPullParser의 getEventType()메소드로 XmlPullParser의 이벤트 타입 상수를 얻어와
		  반복문을 돌면서 xml문서의 끝까지 데이터를 읽어서 원하는 부분만 읽어서 데이타를 가져온다.

			int eventType= xpp.getEventType();
			String tagName="";
			while(eventType !=XmlPullParser.END_DOCUMENT){

				if(eventType==XmlPullParser.START_TAG){
					tagName=xpp.getName();
					if(tagName.equals("원하는 태그")){
						xpp.nextText()메소드로 시작태그와 종료태그사이에 텍스트를 얻어온다.
						혹은 태그에 속성이 있는 경우
						xpp.getAttributeValue(null, "속성명");으로 속성값을 얻는다.


					}
					
					
				}

				else if(eventType ==XmlPullParser.TEXT){
					if(tagName.equals("원하는 태그")){
						xpp.getText()메소드로 시작태그와 종료태그사이에 텍스트를 얻어온다.
					}

				}
				else if(eventType ==XmlPullParser.END_TAG){
					if(tagName.equals("원하는 태그")){
						여기가 찾고자 하는 태그 끝임으로 위에서 얻은 정보를 컬렉션등에 최종적으로 추가
						그리고 기타 값 초기화
						tagName="";등
					}
					
				}
				//다음 이벤트 얻기
				eventType=xpp.next()
			}

	STEP3]메인 액티비티에서 AsyncTask로 구현한 클래스 생성후 execute()호출
			new MyAsyncTask().execute("원격 XML주소");
	STEP4]매니페스트 파일에 인터넷 권한 추가
		<uses-permission android:name="android.permission.INTERNET"/>




	※XmlPullParser의 주요 상수

	XmlPullParser.START-DOCUMENT:XML문서의 시작
	XmlPullParser.END_DOCUMENT:XML문서의 끝
	XmlPullParser.START_TAG:태그의 시작
	XmlPullParser.END_TAG:태그의 끝
	XmlPullParser.TEXT:시작 태그와 종료태그 사이에 있을때.


20-3]JSON 파싱@@@

	JSON(JavaScript Object Notation)]			    
	-경량의 데이터 교환방식으로 인터넷에서 데이타를 주고받을때 표현하는 방법
	-Key와 Value로 구성
	-[]를 사용하여 배열형 Value 사용가능
	-JSON공식 사이트:http://www.json.org

	※안드로이드에는 이미 JSON라이브러리가 포함되어 있다.
	

	예]
	JSON데이타]

	{
	"name" : "홍길동",//문자열
	"age" : 20,//숫자
	"hobbys" : ["등산", "요리"],//배열
	"login" : {	//JSON	
		"id" : "kim",
		"pwd" : 1234
		}
	}

	JSON배열 데이타]

	{
	"members" : [
			{
			"name" : "김길동",//문자열
			"age" : 20,//숫자
			"hobbys" : ["등산", "요리"],//배열
			"login" : {	//JSON	
				"id" : "kim",
				"pwd" : 1234
				}
			},
			{
			"name" : "박길동",//문자열
			"age" : 30,//숫자
			"hobbys" : ["골프", "여행"],//배열
			"login" : {	//JSON	
				"id" : "park",
				"pwd" : 1234
				}
			}
		]
	}

	JSON관련 주요 클래스 멫 메소드]
	
	JSONObject - JSON형식의 데이타와 관련된 클래스
	JSSONArray - JSON형식의 배열 데이타와 관련된 클래스
	
		     JSON데이타 형식 읽을때]
		     1)생성자에 JSON형식 데이타 문자열 전달
			JSONObject object = new JSONObject("JSON형식의 데이타");
		     2) getXXXX("키값")으로 데이타를 읽어 온다
			//문자열
			String name=object.getString("name");
			//숫자
			int age=object.getInt("age");
		        //배열
			JSONArray array = object.getJSONArray("hobbys");
			for(int i=0; i < array.length();i++){
				String hobby = array.getString(i);
				
			}
			//JSON
			JSONObject jsonobject = object.getJSONObject("login");
			String id= jsonobject.getString(id);
			String pwd= jsonobject.getString(pwd);

			※JSON형식의 배열 데이타 
			JSONObject object = new JSONObject("JSON형식의 데이타");
			JSONArray array = new JSONArray("members");
			for(int i=0; i < array.length() ;i++){
				JSONObject jsonobject=(JSONObject)array.get(i);
				String name=jsonobject.getString("name");
				.......

			}


			※
			 {키값:value값}
				JSONObject object = new JSONObject("JSON형식의 값 문자열");
				object.getXXXX(); XXXX는 value값의 데이타 형에 따라 결정,단 getString()으로도 무방.
			 {키값:["데이타1","데이타2"]}JSON형식의 배열형식의 데이타 문자열는 
				JSONObject object = new JSONObject("JSON형식의 배열형식의 데이타 문자열");
				JSONArray array=object.getJSONArray("키값")으로  혹은 JSONArray array=new JSONArray(object.getString("키값");


			  {키값:{"key1":"value1","key2":value2"}} JSON형식의 JSON타입의 데이타 문자열는 
				JSONObject object = new JSONObject("JSON형식의 JSON타입의 데이타 문자열");
				object.getJSONObject("키값")
			  {키값:[{"key1":"value1","key2":value2"},{"key3":"value3","key4":value4"}]} JSON배열형식의 문자열의 데이타는
			                                                                             JSONObject object = new JSONObject("JSON배열형식의 문자열");
												     JSONArray array = new JSONArray(object.getString(키값));



[21. 위치정보와 구글맵]@@@


21-1]위치 정보  

	-안드로이드 기기에서 제공하는 구글 맵을 사용해 맞집이나 나의 최근 위치등을 표시하려면
	 위치 정보를 알아내야한다. 
	 
	- 주요 API
	  LoactionManager-사용자의 최근 위치(위도와 경도)를 알아낼 수 있는 클래스로
	                  주요 메소드]
			  Location getLastKnownLocation(String provider)-최근의 위치 정보 제공을 위한 Location객체 반환
			                                                 provider-최근 위치를 감지할 위치 제공자
									 Location객체의 getLatitude()와 getLongitude()메소드로 위도와 경도를 알아낸다.
			  void requestLocationUpdate(String provider,long minTime,float minDistance,LocationListener listener)-위치변화를 감지할 위치 리스너 등록 설정
			                                                  provider-최근 위치를 감지할 위치 제공자
									  minTime-위치 리스너에 변화감지를 통지할 최소시간(1000분의 1초)
									  minDistance-최소 거리(미터)
									  listener-위치 제공자 상태 및 위치변화시 호출될 위치리스너
			                             
			  void removeUpdate(LocationListener listener)-등록된 리스너 제거
			  String getBestProvider(Criteria criteria,boolean enabledOnly)-주어진 criteria 기준을 만족하는 최적의 위치 제공자 반환.존재하지 않으면 null반환
										         criteria-위치 제공자를 찾기 위한 기준
											 enabledOnly-활성화된 위치 제공자에서 찾고 싶다면 true,
											             모든 위치 제공자에서 찾고 싶다면 false

										          ※만약 주어진 기준에 맞는 위치 제공자가 없는 경우 다음에 나열된 순서로 기준을 완화하면서 적당한
											    위치 제공자를 찾아줌]
											    1.전력소비량 2.정확도 3.방향 사용여부 4.스피드 사용여부 5.고도 사용여부.
											    -비용부과여부는 기준완화 대상이 아니다


	  LocationListener-사용자의 위치 변화를 감지 할 수 있는 인터페이스.
			주요 추상 메소드]
			void onLocationChanged(Location location)-위치가 변경될때 호출된다.
								 location-새로운 위치 정보를 가지고있는 Location객체

			void onProviderDisabled(String provider)-위치제공자가 사용자에 의해 비활성화 되었을때 호출된다.
			void onProviderEnabled(String provider) -위치제공자가 사용자에 의해 활성화 되었을때 호출된다.
			void onStatusChanged(String provider,int status,Bundle extra)-위치 제공자의 상태가 변경되었을때 호출된다.
									              status - 위치 제공자의 상태로
								                      OUT_OF_SERVICE:서비스 범위 밖.
										      TEMPORARILY_UNAVAILABLE:일시적으로 이용 불가.
										      AVAILABLE:이용가능
								


	
        - Criteria - 특정 조건 제공시 안드로이드 시스템이 최적의 위치 제공자를 찾아주는 기능 제공을 위한 클래스
		주요 메소드]
		void setAccuracy(int): 정확도 설정
		                                ACCURACY_FINE-더 정확.ACCURACY_COARSE-부 정확
		void setAltitudeRequired(boolean)- 고도 필요 여부 설정
		void setBearingRequired(boolean)- 방향 필요 여부 설정
		void setSpeedRequired(boolean)-속도 필요 여부 설정
		void setCostAllowed(boolean)-비용 부과 여부 설정
                void setPowerRequirement(int)-전력 소비량 설정
					       NO_REQUIREMENT:전력소비 없음
					       POWER_LOW:전력소비 낮음
					       POWER_MEDIUM:전력소비 중간
					       POWER_HIGH:전력소비 높음


		

	  ※위 두 API를 사용하기 위해서는 반드시 아래 조건들을 만족해야 한다.
	  -에뮬레이터는 구글 APIs로 실행
          -매니페스트 파일에 ACCESS_FINE_LOCATION권한 설정(ACCESS_FINE_LOCATION권한 설정시 자동으로 ACCESS_COARSE_LOCATION권한도 부여됨)
          -DDMS로 에뮬레이터에 위치 정보를 보낸다
          -GPS가 켜져 있어여 한다(안드로이드 코드로 GPS를 켜는 것은 안드로이드 1.5부터 금지.고로 환경 설정 파일을 보여주고 사용자가 직접 GPS를 켜도록 해야한다)
	   홈->설정->위치 ㅡ->ON으로 설정


	  ※위치 제공자: 안드로이드 시스템에 사용자의 위치정보를 제공하는 수단으로 LocationManager 상수로 정의되어 있음.
		GPS_PROVIDER:GPS를 사용하여 위치 정보 제공.무료고 정확도 높다
                NETWORK_PROVIDER:무선 인터넷을 제공하는 기지국(Cell Tower)나 와이파이 AP(Access Pointer)에서 알려주는 위치 정보 사용.지속적으로  모든 곳에서 위치정보 제공받기 힘듬
                PASSIVE_PROVIDER:API 2.2부터 제공된 위치 제공자이며 다른 위치 제공자로부터 위치정보를 제공받아 제공

	※위도경도 알아내기-https://www.google.co.kr/maps 에서 마우스 우클릭->이곳이 궁금한가요?선택
                          

21-2]구글맵
	
	-구글사에서 제공하는 구글 맵 API를 사용하여 안드로이드 화면에  구글 맵 표시
	-구글맵 서비스 v2가 새로 추가되면서 지도를 화면에 보여주기 위한 방법이었던 
	 MapView태그 사용 불가능(이클립스용 AVD는 Google Map API2가 작동 안함)		
	-구글 맵 사용]
	    1.Google Play Service모듈 설치-구글맵 서비스 v2는 Google Play Service모듈 사용
	      SDK Manager에서 설치(Google API 에물레이터는 이미 설치가 되어있음)
	    2.지도 API키를 발급받기 위한 SHA1코드 얻기-2017.9.14일 현재 필요 없어짐
		2-1)JDK설치폴더\bin>keytool.exe -list -v -keystore C:\Users\컴퓨터명\.android\debug.keystore(엔터)
		    비밀번호를 물어보면 android입력
		2-2)결과 중 SHA1부분의 코드 복사(예: SHA1: 7B:31:50:B9:74:F0:38:03:FF:C0:70:E2:59:1C:11:12:C9:8A:5C:4B)

	    3.Google맵을 사용할 프로젝트 생성-Google맵은 응용프로그램마다 별도로 인증을 받아야한다.
	     
	    4.Google에 Google맵을 상요할 프로젝트 등록.(구글계정 필요)
		4-1)https://console.developers.google.com/에 접속하여 로그인
		4-2)상단 프로젝트 목록 클릭->새 프로젝트 클릭->프로젝트명 입력후 [만들기]버튼 클릭->팝업창에서 만든 프로젝트 명 클릭하면
		    프로젝트 목록이 만든 프로젝트로 변경됨
		4-3)대시보드 탭 메뉴의 시작하기 섹션에서 API탐색 및 사용 설정 클릭->상단의 API및 서비스 사용설정 클릭 
		   ->Maps SDK for Android 클릭->사용설정 버튼 클릭
		4-4)왼쪽의 [API]메뉴 클릭후 사용 설정된 API의 [Maps SDK for Android]클릭
		4-5)사용자 인증정보탭 메뉴에서  API 및 서비스의 사용자 인증 정보 클릭-> 상단의 [사용자 인증정보 만들기] 클릭-> API키 클릭
		   아래 과정은 사라졌음.
		   이름은 패키지 이름에 입력할 패키지명 입력,패키지 이름에는 3에서 생성한 프로젝트의 패키지명 입력.SHA-1 인증서 지문에는 2에서 얻은 SHA1코드 입력후
		   생성 버튼을 누른다(2017.9.14일 현재 API키만 클릭해도되도록 변경됨)
		4-6)API키 발급됨. 복사후 저장
		    
		
	     5.Google Play service의 라이브러리 사용 설정
			
		Project Tree에서 [Gradle Scripts]=[build.gradle(Module:app)]를 더블클랙해서 열어 
		dependemcies부분에 아래 코드 추가후  Sync Now버튼 클릭

		

		
		메이븐 리포지토리에서 최신버전 확인
		implementation 'com.google.android.gms:play-services-maps:17.0.0'
		
		     
	
	     6.매니페스트 파일에 권한 및 발급받은 지도 키 그리고 기타 설정
			

		    		  
		    <!--구글맵을 사용하기위한 인터넷,외부 저장소 접근.GMS사용등 지정 즉 인터넷으로 지도를 가져오게 됨으로 인터넷 접속권한 및 GPS 사용시 GPS위치정보 확인 권한 필요등-->
		    <uses-permission android:name="android.permission.INTERNET"/>	    
		    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>	    
		   

		    <application  ~>
			 <!-- Google Play Service버전 지정-->			
			<meta-data android:name="com.google.android.geo.API_KEY"  android:value="4에서 발급받은 API키 입력"/>
		    </application>

	    7. 구글 맵 표시용 레이아웃(
		<fragment 
			xmlns:android="http://schemas.android.com/apk/res/android"
			xmlns:map="http://schemas.android.com/apk/res-auto"  //맵능 표현하기 위한 네임 스페이스(map이라는 접두어로 맵 초기설정)
			android:id="@+id/map"

			android:layout_width="match_parent"
			android:layout_height="match_parent"
			class="com.google.android.gms.maps.MapFragment"
			>
		    <!--

			android:name="com.google.android.gms.maps.MapFragment"  <!-- class속성 대신 사용가능(값은 MapFragment로 고정-->
			map:cameraTargetLat="37.557"
			map:cameraTargetLng="126.933"
			map:cameraZoom="16"  //화면 zoom레벨
			-->


		</fragment>

	    8.메인 액티비티는 Activioty가 아닌 FragmentActivity상속



	    ※테스트:DDMS로 위도와 경도 변경후 테스트하면 해당 위치로 지도 이동
	    ※Google Maps Android API v2부터는 사용할 패키지마다 따로 따로 인증키를 얻어야한다

[22. 서비스]@@@

	-특정 액티비티와 상관없이 백그라운드에서 실행되는 프로세스. 
	-화면을 구성하는 레이아웃이 필요없다.
	-백그라운드에서 계속적으로 장시간 동작해야하는 기능등을 서비스로 구현
	 예를 들면 음악을 들으면서 다른 작업등을 할 경우 음악을 재생하는 부분을 서비스로 구현한다.
	-서비스도 애플리케이션의 구성요소중의 하나임으로 액티비티처럼 매니페스트 파일에 등록해야 한다.

22-1]서비스 생명주기

	
	
		Call to startService()(서비스 시작)--->onCreate()--->onStartCommand()--->onResume()--->서비스 실행--->서비스는 스스로 혹은 사용자에의해 중단된다--->onDestroy()--->서비스 종료

		onCreate():서비스가 생성될때 호출됨.
		onStartCommand():startService()메소드에 의해 서비스가 시작될때 호출됨.
		onDestroy():stopService()메소드에 의해 서비스가 중지될때 호출됨




22-2]서비스 작성 절차.
     
	 	

		1) 서비스 작성
			- Service 상속
			- 메인쓰레드에서 실행되므로 오래 걸리는 작업은 별도 쓰레드로 분리.즉
			  onCreate()나 onStartCommand()메소드안에서 스레드 생성후 start()호출

		
		2) 액티비티에서 호출

		
		-ComponentName startService(Intent service):주어진 서비스의 시작.
		                              
		-boolean stopService(Intent service):서비스를 중지.서비스가 실행중이 아니라면 어떤 일도 발생하지 않는다.

		※API level 21부터는 Explicit Intent만 허용.즉 Service를 Start하거나 Stop하고자 한다면 Intent에 Class명을 지정해야 한다.
		예]Intent service = new Intent(Context,MusicService.class);
					     
		3) 매니페스트 파일 설정
		   - startService() 와 stopService()메소드에 설정한 인텐트의 액션을 처리 할 수 있도록 서비스와 인텐트 필터 등록
			 <service android:name=".MusicService" android:enabled="true">

			</service>



[23. 브로드캐스트 리시버]@@@

	- 안드로이드에서 발생하는 여러 이벤트(문자 메시지 도착,부팅완료,SD카드 탈부착,날짜변경,배터리방전등)
          를 감지하는 컴포넌트
          안드로이드는 위와같은 이벤트가 발생하면 방송 신호를 보낸다. 이 신호를 받아서 처리하는것이
          바로 브로드 캐스트 리시버이다.
          대표적인 응용은 배터리 상태 확인.안드로이드는 배터리의 상태가 변할때마다 이를 방송한다.

	  즉 브로드캐스트를 사용하면 안드로이드에서 발생하는 여러 브로드캐스트 즉, 이벤트를 감지할 수 있다.
	  이러한 이벤트는 모두 인텐트의 액션으로 전달된다.

	-사용자 인터페이스를 갖지 않는다.

	-실행하지 않아도 응용 어플리케이션에 BR이 등록되어 있고 해당 방송이 브로드캐스트 된다면 자동으로 실행된다.


	 -인텐트의 브로드 캐스트 액션]
		

		ACTION_TIME_CHANGED:시간이 변경되었을때 발생하는 액션
		ACTION_DATE_CHANGED:날짜가 변경되었을때 발생하는 액션
		ACTION_BATTERY_CHANGED:배터리 정보가 변경되었음을 알려주는 액션
		ACTION_BATTERY_LOW:거의 방전되었을때
		ACTION_BATTERY_OKAY:방전상태에서 정상수준으로 올라왓을때
		ACTION_POWER_CONNECTED:외부전원이 연결되었음을 알려주는 액션
		ACTION_BOOT_COMPLETED:부팅이 완료 되었을때 발생
		ACTION_SCREEN_ON:화면이 커졌을때 발생
		ACTION_SCREEN_OFF:화면이 꺼졌을때 발생되는 액션
		ACTION_MEDIA_MOUNTED:외부 저장 미디어가 추가될때 발생하는 액션
		ACTION_MEDIA_UNMOUNTED:외부 저장 미디어가 제거될때 발생하는 액션
		※이 액션 상수들은 android.intent.action.ACTION_TIME_CHANGED처럼 상수로 정의 되어 있다.



							+------Appication------+
						>>>>	|  BroadcastReceiver   |
							+----------------------+

							+------Appication------+
	안드로이드 시스템 >>>>BroadCast		>>>>    |  BroadcastReceiver   |
							+----------------------+

							+------Appication------+
						>>>>	|  BroadcastReceiver   |
							+----------------------+


	-브로드 캐스트 리시버 구현
		
		1)BroadcastReceiver를 상속받은 클래스 작성
		  onReceive(Context context, Intent intent) 오버라이딩-방송 수신시 자동으로 호출되는 메소드로 방송 수신시 수행할 로직을 작성. 
				context : BR이 실행되는 컨텍스트
				intent : 수신된 방송 내용. 액션은 어떤 방송인지, 추가정보는 Extra나 인텐트의 기타멤버에 저장되어 전달


		2)BroadcastReceiver등록-브로드캐스트 리시버를 등록하는 방법은 두가지 방법이 있다.

			방법1]매너 페스트 파일의 <application>요소안에 <receiver>로 선언한다.

				예] 
				
				<receiver android:name="BroadcastReceiver를 상속받은 클래스" >
				   <intent-filter><!-- 수신할 필터 등록 즉 수신할 방송 내용 등록-->	
				     <action android:name="수신할 액션" />
				   </intent-filter>
				</receiver>

				※단,ACTION_BATTERY_CHANGED는 자바코드(registerReceiver())로 등록해야 한다
				※※※
				오레오에서 Boradcast 제약사항이 추가되었다.
				https://developer.android.com/about/versions/oreo/background.html#broadcasts
				더 이상 명시적 브로드캐스트를 제외한 리시버를 AndroidManifest.xml에 등록할 수 없다.
				암시적 브로드캐스트 리시버는 런타임에 Context.registerReceiver()를 통해서만 등록이 가능하다.

				단,서명 권한이 요구되는 브로드캐스트는 암시적 브로드캐스트 제한에서 제외된다.
				이는 동일한 인증서로 서명된 앱으로만 브로드캐스트가 전송되기 때문이다.
				즉 암시적 브로드캐스트를 전송할 때, 퍼미션을 명시해주면 해당 퍼미션을 가진 Receiver에게만  
				브로드캐스트가 전송되므로, 암시적 브로드캐스트 제약에서 제외된다.
				sendBroadcast(new Intent("your.action.name"), "your.permission.name")



				

			방법2]자바코드로 등록-자바코드로 등록할 때에는 registerReceiver(BroadcastReceiver객체,IntentFilter객체)메서드와 
			      unregisterReceiver(BroadcastReceiver객체)메서드를 사용하면 된다.
			      액티비티의 onResume()메서드에서 registerReceiver()를 호출하고 onPause()메서드에서 unregisterReceiver()메서드를 호출.

	

	-sendBroadcast(송신)
		:시스템에서 송신된 내용을 개발자가 수신할 수도 있지만, 개발자가 직접 송신을 할 수도 있다.


[24. 컨텐츠 프로바이더]@@@
	

	- 애플리케이션간의 데이타를 공유할 수 있게 해주는  컴포넌트. 즉 ContentProvider를 상속받은 클래스를 작성하고 CRUD메소드를 작성
	  하여 이 클래스를 다른 곳에서 사용할 수 있게 하는 방식
	- 안드로이드 시스템에서 content://로 시작하는 모든 URI는 콘텐츠 프로바이더를 통해 제공되는 데이터를
	  의미한다. 다시말해 콘텐트 프로바이더는 URI(Uniform Resource Identifier)의 인스턴스가 가리키는 
          특정 데이터를 제공할 수 있게 준비된 컴포넌트이다. 콘텐트 프로바이더에 접근할 때 사용할 수 있는 객체가 
          콘텐트 리졸버(ContentResolver)이다. 이 컨텐츠 리졸버를 통해 컨텐츠 프로바이더가 제공하는 데이타에 접근 할 수 있다.
	- 컨텐트 프로바이더가 제공하는 실제 데이터는 파일 시스템이나 데이타베이스등에 있을 수 있다.

	안드로이드 시스템에 기본으로 탑재된  컨텐츠 프로바이더]

	----------------------------+---------------------------------------------------
	애플리케이션                | 설명
	----------------------------+---------------------------------------------------
	주소록                      | 주소록 조회 .수정등
	Contacts                    |
	----------------------------+---------------------------------------------------
	통화기록                    | 부재중 통화.발신자,통화시간조회등
	CallLog                     |
	----------------------------+---------------------------------------------------
	브라우저                    | 북마크.브라우저 기록등
	Browser                     | 
	----------------------------+---------------------------------------------------
	미디어 갤러리               | 비디오,오디오,이미지등 멀티미디어 데이터조회.수정등
	MediaStore                  |
	----------------------------+----------------------------------------------------
	환경 설정                   | 안드로이드 환경 설정 조회.수정등
	Settings                    | 
	----------------------------+----------------------------------------------------


	URI 기술 형식]

	content://com.myandroid.contentprovider.MyContentProvider/path/kim
            ⓐ                         ⓑ                          ⓒ  ⓓ


	ⓐ 콘텐트 프로바이더임을 의미하며, 항상 content://로 기술.
	ⓑ Authority라고 하며 완전한 클래스 이름을 기술. 콘텐트 프로바이더를 구분하는 이름이며 매니페스트파일에 등록때 사용하는 이름
	ⓒ path라고 하며 콘텐트 프로바이더가 제공하는 데이터 타입을 지정. 생략가능
	ⓓ 특정 레코드를 지정할때 사용하는 ID이다. 생략가능


	24-1]안드로이드 시스템에서 제공하는 컨텐츠 프로바이더 사용하기

	1]매니페스트 파일에 android.permission.READ_CONTACTS 권한으로 use-permission추가
	2]getContentResolver() 메소드 호출해서 ContentResolver 객체를 통해 주소록 애플리케이션에서 제공하는 콘텐트 프로바이더(URI형태로 제공됨)에
	  접근

	  ContentResolver contentResolver=getContentResolver;

	3]ContentResolver()의 query()메소드로 Cursor객체 얻기
	 Cursor cursor=contentResolver.query(ContactsContract.Contacts.CONTENT_URI,null,null,null,null);
	//ContactsContract.Contacts.CONTENT_URI 는 content://com.android.contacts/contacts 와 같음
	

	테스트]실행시 데이타가 없음. 모듈레이터의 Contacts메뉴에서 이름을 넣은 후 테스트 해야 함
               즉 안드로이드 OS에서 제공하는 콘텐트 프로바이더 형태의 주소록을
               공유해서 사용하는 형태임.



	24-2]내가 만든 컨텐트 프로바이더 사용하기



	1]ContentProvider를 상속받은 클래스 작성

		public class MyContentProvider extends ContentProvider{

		    //URI목록 값을 설정
		    private String URI="content://com.myandroid.contentprovider_32_2_1.MyContentProvider/member";
		    //문자열을 Uri객체로 파싱
		    private Uri contentUri =Uri.parse(URI);
		    private static UriMatcher uriMatcher;//다른 어플에서 내가만든 콘텐츠 프로바이더를
		    //사용할 수 있도록 URI를 매칭

		    //디비 설정-다른 어플에서 공유하는 데이타베이스
		    //ContentProvider를 상속받아 SQLiteOpenHelper클래스를 상속 받지 못함으로
		    //외부 클래스로 만들거나 내부 클래스로
		    //SQLiteOpenHelper를 상속받은 클래스로 테이블을 생성
		    private SQLiteDatabase db =null;

		    static{
			uriMatcher =new UriMatcher(UriMatcher.NO_MATCH);//최초는 노 매치
			//addURI(Authorities박스에 입력한 값,"path",임의의 숫자)
			uriMatcher.addURI("com.myandroid.contentprovider_32_2_1.MyContentProvider", "member", 1);
		    }


		    //데이타 베이스 설정]
		    @Override
		    public boolean onCreate() {
			Context context = getContext();
			DatabaseHelper dbmember =new DatabaseHelper(context,"AndroidDB",null,1);
			db = dbmember.getWritableDatabase();

			return (db==null) ? false : true;

		    }
		    //데이터 베이스에 데이터를 검색하는 메소드-다른 어플에서 호출해서 데이타 검색
		    @Override
		    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
			//다른 어플에서 모든 데이타 검색후 알아서 하도록
			//다른 조건은 모두 null로 설정
			Cursor cursor = db.query("MEMBER", null, null, null, null, null, null);
			//커서의 결과셋이 변경될경우 알림을 받을 콘텐트 리졸버 객체를 등록
			cursor.setNotificationUri(getContext().getContentResolver(), uri);
			return cursor;
		    }

		    @Override
		    public String getType(Uri uri) {
			return null;
		    }

		    @Override
		    public Uri insert(Uri uri, ContentValues values) {
			Uri muri =null;
			//넘어온 URI가 제대로 매핑도는지 판단
			//판단시 숫자는
			//uriMatcher.addURI("com.myandroid.contentprovider_32_2_1.MyContentProvider", "member", 1);
			//에 작성한 세번째 인자값 지정
			if(uriMatcher.match(uri)==1){//URI가 제대로 매칭이된다면
			    long id =db.insert("MEMBER", null, values);

			    if(id>0){
				muri = ContentUris.withAppendedId(contentUri, id);
				getContext().getContentResolver().notifyChange(muri, null);
			    }else{
				Log.i("MyContentProvider","디비 입력 에러");
			    }
			}
			return muri;
		    }
		
		    //외부에 공개하지 않을때는 아래처럼 오버라이딩후 코드를 작성하지 않으면 된다.

		    @Override
		    public int delete(Uri uri, String selection, String[] selectionArgs) {
			return 0;
		    }

		    @Override
		    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
			return 0;
		    }
		}

	
	2]매니페스트파일의 <application안에 콘텐트 프로바이더를 설정

		<provider
		    android:authorities="com.myandroid.contentprovider_32_2_1.MyContentProvider"
		    android:name=".MyContentProvider"
		    android:exported="true"
		    />
		authorities: 프로바이더의 완전한 클래스명 입력
		name: 프로바이더 클래스명
		exported:외부에 해당 컴포넌트 접근을 허용하는 설정(true)

       


	

	
	
	
	
	3]테스트 - 패키지가 다른 앱 생성후 getContentResolver()메소드로 콘텐츠 리졸버를 얻은후 CRUD작업 


	public class MainActivity extends ListActivity {

	    private String URI="content://com.myandroid.contentprovider_32_2_1.MyContentProvider/member";

	    @Override
	    protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		//setContentView(R.layout.activity_main);
		ContentResolver cr =getContentResolver();

	       
		//입력]
		ContentValues values =new ContentValues();
		values.put("user", "romantist");
		values.put("name", "낭만자객");

		cr.insert(Uri.parse(URI), values);
	  
		Cursor cursor = cr.query(Uri.parse(URI), null, null, null, null);

		//검색]
		setListAdapter(new SimpleCursorAdapter(this, android.R.layout.simple_list_item_1 , cursor,
			new String [] {"name"} , new int [] { android.R.id.text1},SimpleCursorAdapter.NO_SELECTION));

	 
	    }


	}

[Sharedpreferences] @@@

-초기 설정값 또는 자동 로그인 여부등 간단한 값을 저장할때 사용하는 클래스
-앱 안에 파일 형태로 데이터를 저장
-앱이 삭제되기 전까지 보존된다.

1.Sharedpreferences인스턴스 얻기
	
	getSharedPreferences(String name,int mode)]
		-특정 이름을 가진 SharedPrefrences를 생성
		-주로 앱 전체에서 사용
		-mode는 private으로 사용할지 여부(보안이 강화되어 private으로 )
   
2.데이타 저장
	
	-SharedPreferences.Editor객체 이용
	-데이타의 형태에 따라 putXXX(key,value)메소드로
         데이타 저장
	-저장후 commit()메소드 호출로 변경사항 저장
	
	예]
	SharedPreferences preferences = getSharedPreferences("preferences",MODE_PRIVATE);
	SharedPreferences.Editor editor =preferences.edit();
	editor.putString("key","데이타 입니다");
	editor.commit();

※SharedPreferences로 저장할 수 있는 데이타 타입-Boolean,Integer,Float,Long,String

3.데이타 가져오기
	-SharedPreferences인스턴스의 getXXX(키값,디폴트값)
         메소드로 얻는다
	

	예]
	SharedPreferences preferences = getSharedPreferences("preferences",MODE_PRIVATE);

	String key=preferences.getString("key","키에 해당하는 값이 없는 경우");

4.데이타 삭제
	-SharedPreferences.Editor의 remove(키값)으,로 삭제
	예]
		SharedPreferences preferences = getSharedPreferences("preferences",MODE_PRIVATE);
	SharedPreferences.Editor editor =preferences.edit();
	editor.remove("key");
	editor.commit();
	
	//모든 데이타 삭제시는 remove(키값)대신 clear()호출
	※파일은DDMS의 File Explorer탭에서 
     /data/data/패키지/shred_prefs/이름.xml로 확인 가능
     이름은 getSharedPreferences(String name,int mode)메소드의
     name에 지정한 값이다.
================추가 내용들==============================

  
[※안드로이드 소프트 키패드 화면 가림 방지]

	-매니페스트 파일의 activity 속성에 추가해준다
	-android:windowSoftInputMode="설정값"
	
	예]android:windowSoftInputMode="adjustPan|adjustResize"
	-설정값들
	stateUnspecified : 키보드의 디폴트 설정값
	stateUnchanged : 키보드의 마지막 상태로 유지
	stateHidden : 사용자 액티비티 선택시 키보드 숨김
	stateAlwaysHidden : 액티비티의 메인 윈도우가 입력 포커스를 가질 때 키보드는 항상 숨김
	stateVisible : 사용자가 액티비티 메인 윈도우 앞으로 갈 때 키보드 보여짐
	stateAlwayVisible : 사용자가 액티비티를 선택할 때 키보드를 보여줌
	adjustUnspecified : 스크롤 할 수 있는 레이아웃 뷰드을 가지고 있다면 윈도우 크기 재조정, 메인윈도우의 디폴트 값
	adjustResize : 스크린에 키보드 공간을 만들기 위해 메인 윈도우 크기를 재조정
	adjustPan : 키보드 공간을 만들기 위해 메인 윈도우의 크기가 재조정 되지 않음
	
	adjustPan : 키보드 공간을 만들기 위해 메인 윈도우의 크기가 재조정 되지 않음

[※PendingIntent]
	PendingIntent는 Intent 객체를 감싸는 객체다. 
	PendingIntent의 목적은 그것이 포함하고 있는 인텐트를 외부의 
	다른 어플리케이션에서 실행할 수 권한을 주는 것이다.
    (PendingIntent는 마치 자신의 프로세스에서 실행되는 것과 같이 처리된다)

	-PendingIntent가 주로 사용되는 케이스
 
	CASE 1:유저가 Notification를 이용해서 특정 액션을 수행할 때, 
	      실행될 인텐트를 생성한다.
	      (이 경우 안드로이드 시스템의 NotificationManager가 Intent를 실행한다.)
 
	CASE 2:유저가 AppWidget을 이용해서 특정 액션을 수행할 때, 
	       실행될 인텐트를 생성한다.
		  (이 경우 홈 스크린 어플리케이션이 Intent를 실행한다)
 
    CASE 3:미래의 특정 시점에 실행될 인텐트를 선언한다. 
		 (이 경우 안드로이드 시스템의 AlarmManager가 인텐트를 실행한다.)
	-PendingIntent로 4대 컴포넌트 실행하기
	 1.액티비티를 시작할 인텐트를 생성시:PendingIntent.getActivity()
     2.서비스를 시작할 인텐트를 생성시:PendingIntent.getService() 
	 3.BroadcastReceiver를 시작할 인텐트를 생성시:PendingIntent.getBroadcast()
	-PendingIntent의 Flag값
	 1.FLAG_CANCEL_CURRENT : 이전에 생성한 PendingIntent 는 취소하고 새롭게 생성.
     2.FLAG_NO_CREATE : 이미 생성된 PendingIntent 가 없다면 null 을 return .
                        생성된게 있다면 그 PendingIntent 를 반환 즉 재사용 전용이다.

	 3.FLAG_ONE_SHOT : 이 flag 로 생성한 PendingIntent 는 일회용이다.

     4.FLAG_UPDATE_CURRENT : 이미 생성된 PendingIntent 가 존재하면 해당 Intent 의 
	                         Extra Data 만 변경한다.
	 
[※Intent의 주요 Flag들]

	-액티비티 스택:안드로이드 시스템은 Activity를 Activity Stack을 통해 관리 한다.
                   기존 Stack의 개념과 동일
				   이 액티비티 스택을 Task라고도 한다 즉 Activity가 스택 구조에
				   쌓이게 된다.
	               즉 안드로이드의 Activity 는 새로이 실행될 때마다 Stack 에 
				   Activity 를 저장해 둠.
				   여러 개의 Activity 가 여러 단계의 Intent 로 연결되어 있다면, 
				   모두 메모리에 저장되어 Application 자체가 매우 무거워 짐.
				   메모리를 를 관리할 방법이 필요한데, Flag 로 할 수 있다.
				   
	-스택의 가장 아래에 놓인 액티비티(MainActivity)를 Root Activity라고한다
	-스택의 최상위에 놓인 액티비티를 Top 액티비티라 한다
	
	-FLAG_ACTIVITY_SINGLE_TOP:생성하려는 액티비티와 동일한 액티비티가 스택 최상위에 
	                          없을 경우 액티비티를 새로 생성
	                          있는 경우 재 사용.
							  예] D액티비티로 전환시
							  -FLAG 미사용시
							  A-B-C-D ---->A-B-C-D-D
							  -FLAG 사용시:D액티비티 재사용
							  A-B-C-D(1) ---->A-B-C-D(1)
	-FLAG_ACTIVITY_CLEAR_TOP:생성하려는 액티비티와 동일한 액티비티가 스택 내부에 있을 경우,
                             기존 동일한 액티비티 위의 모든 액티비티를 종료 시키고 
							 기존 액티비티를 새로 생성된 액티비티로 교체한다.
							예] B액티비티로 전환시							 
							 -FLAG 미사용시
							  A-B-C-D ---->A-B-C-D-B
							 -FLAG 사용시:B액티비티 생성후 새로운 액티비티로 대체
							 A-B(1)-C-D ---->A-B(2)
							 
	-FLAG_ACTIVITY_NO_HISTORY:이 플래그를 사용하여 스택위에 추가된 액티비티는 위에 
	                          새로운 액티비티가 추가될 경우, 이 액티비티는
							  스택에 쌓이지 않고 제거된다. 
							  즉, 최상위 액티비티가 아닐 경우 스택에 쌓이지 않는 
							  액티비티를 만든다.
							  예]D를 NO_HISTORY 플래그로 생성한 경우							  
							  A-B-C-D
							  위 상태에서 E를 새롭게 추가한 경우-D는 바로 제거가 안됨
							  A-B-C-[D]-E
							  E가 추가된 상태에서 finish 를 호출하였을 때, 
							  스택에서 같이 제거되었다.
							  즉 E액티비티에서 finish()메소드 호출시
							  A-B-C 가 스택에 남게된다.

							  즉 결과적으로 D는 다시 launch 되지 않는다
[※콘솔에서 앱의 데이타에 접근하기]
	1. 안드로이드 sSDK가 설치된 디렉토리의 platform-tools폴더로 이동
		dos>cd C:\Users\kosmo_0\AppData\Local\Android\sdk\platform-tools
	2. 연결된 기기목록 보기
	   dos>adb devices
	3. 2번의 기기명으로 해당 기기에 접속하여 shell모드로 들어가기
	
	   dos>adb -s 장비명 shell
	4. 해당에 대한 app권한 얻기(이전은 adb권한임)
	   run-as 패키지명
    5. cd 나 ls명령으로 디렉토리 변경 및 목록 보기
	
	※sqlite3명령어로 sqlite3 데이타베이스에 접속
      데이타베이스가 생성된 디렉토리로 이동후 
	  shell>sqlite3 데이타베이명	
[※모비즌-스마트폰과 PC연결]
	1. PLAY STORE에서 모비즌 미러링 FOR SAMSUNG검색후 스마트폰에 설치
	2. PC에서 https://www.mobizen.com/?locale=kr 접속후 미러링 PC버전 다운후 설치

	
	